#include <QFile>
#include <QtXml>
#include <QFileInfo>
#include <Eigen/Dense>
#include "OrientationProcessMonitor.h"
#include "../MicMac/AperoModelReader.h"
#include "../MicMac/MicMacEOReader.h"
#include "../TiePointsIO.h"
#include "../FraserModel.h"
#include "../RadialBasic.h"
#include "../RadialExtended.h"

using namespace PW;

OrientationProcessMonitor::OrientationProcessMonitor(QString& strError,
                                                     QObject *parent) :
    ExternalInterfaceProcessMonitor(parent)
{
    mStdOut = new QTextStream(stdout);
    mTiePointsManager=NULL;
    mLibSDGAP=NULL;
    mUpdateAccuracies=false;
    mCalibrationIsFixed=false;
    initializeCalibrationModels(strError);
}

bool OrientationProcessMonitor::setBundleAdjustmentParametersWithSDAG(bool writeSDGAPInputFiles,
                                                                      QString &strError)
{
    if(mLibSDGAP==NULL)
    {
        strError=QObject::tr("libSDGAP object is NULL");
        return(false);
    }
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
//        sdgapInputFilesPath=mProjectPath;
        sdgapInputFilesPath=mTmpFolder;
    }
    if(!mLibSDGAP->setParametersOptions(sdgapInputFilesPath,
                                        strError))
    {
        return(false);
    }
    if(!mLibSDGAP->setLeastSquaresParameters(sdgapInputFilesPath,
                                             strError,
                                             mPrioriStandardDeviationOfUnitWeight,
                                             mMaximumNumberOfIterations))
    {
        return(false);
    }
    return(true);
}

bool OrientationProcessMonitor::createTiePointsManager(QString &strError,
                                                       int gridSize)
{
    if(mTiePointsManager!=NULL)
        delete(mTiePointsManager);
    mTiePointsManager=new TiePointsManager(mImageCoordinatesPrecision,
                                           mSensorSize.width(),
                                           mSensorSize.height(),
                                           gridSize,
                                           mImagesIds);
    if(!mTiePointsManager->setFromMapContainers(mImagesIdsTiePoints,
                                                mImagesFirstColumnsTiePoints,
                                                mImagesFirstRowsTiePoints,
                                                mImagesSecondColumnsTiePoints,
                                                mImagesSecondRowsTiePoints,
                                                mMatchesAccuracies,
                                                strError))
    {
        delete(mTiePointsManager);
        return(false);
    }
    return(true);
}

bool OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile(QString &strError)
{
    mGeometryGCPs.clear();
    mIsControlGCPs.clear();
    mImageCoordinatesGCPs.clear();

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Lectura de las GCPs
    QDomNodeList gcpsNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
    if(gcpsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
        return(false);
    }
    if(gcpsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
        return(false);
    }
    QDomNode gcpsNode=gcpsNodes.at(0);
    QDomElement gcpsElement=gcpsNode.toElement();
    QDomNodeList gcpNodes=gcpsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCP);
    if(gcpNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_GCP);
        return(false);
    }
    for(int nGcp=0;nGcp<gcpNodes.size();nGcp++)
    {
        QDomElement gcpElement=gcpNodes.at(nGcp).toElement();
        QString name=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_NAME);
        if(name.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_NAME)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        if(mGeometryGCPs.contains(name))
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nDuplicated GCP name %1")
                    .arg(name);
            return(false);
        }
        QString type=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_TYPE);
        if(type.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_TYPE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        if(type.compare(ORTOSKYXMLMATCHESFILE_GCP_TYPE_CONTROL,Qt::CaseInsensitive)!=0
                &&type.compare(ORTOSKYXMLMATCHESFILE_GCP_TYPE_CHECK,Qt::CaseInsensitive)!=0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot valid attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_TYPE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        bool isControl=false;
        if(type.compare(ORTOSKYXMLMATCHESFILE_GCP_TYPE_CONTROL,Qt::CaseInsensitive)==0)
            isControl=true;
        QString strX=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_X_COORDINATE);
        if(strX.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_X_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        bool toFloat=false;
        float x=strX.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_X_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QString strY=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Y_COORDINATE);
        if(strY.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Y_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        toFloat=false;
        float y=strY.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Y_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QString strZ=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Z_COORDINATE);
        if(strZ.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Z_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        toFloat=false;
        float z=strZ.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_Z_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QString strSx=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SX_COORDINATE);
        if(strSx.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %1")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SX_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        toFloat=false;
        float sx=strSx.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SX_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QString strSy=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SY_COORDINATE);
        if(strSy.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SY_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        toFloat=false;
        float sy=strSy.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SY_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QString strSz=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SZ_COORDINATE);
        if(strSz.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SZ_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        toFloat=false;
        float sz=strSz.toFloat(&toFloat);
        if(!toFloat)
        {
            strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNot float attribute %1 value in GCP in position %2")
                    .arg(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_SZ_COORDINATE)
                    .arg(QString::number(nGcp+1));
            return(false);
        }
        QVector<float> geometryGcp;
        geometryGcp.push_back(x);geometryGcp.push_back(y);geometryGcp.push_back(z);
        geometryGcp.push_back(sx);geometryGcp.push_back(sy);geometryGcp.push_back(sz);
        QDomNodeList photoNodes=gcpElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_GCP_TAG_IMG);
        for(int nI=0;nI<photoNodes.size();nI++)
        {
            QDomElement imgElement=photoNodes.at(nI).toElement();
            QString imageId=imgElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_NAME);
            if(imageId.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_ID)
                        .arg(QString::number(nI+1));
                return(false);
            }
            if(!mImageNames.contains(imageId))
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no valid image name attribute %2")
                        .arg(QString::number(nGcp+1))
                        .arg(imageId);
                return(false);
            }
            QString strColumn=imgElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_X_COORDINATE);
            if(strColumn.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_X_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            toFloat=false;
            float column=strColumn.toFloat(&toFloat);
            if(!toFloat)
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no float value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_X_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            QString strRow=imgElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_Y_COORDINATE);
            if(strRow.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_Y_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            toFloat=false;
            float row=strRow.toFloat(&toFloat);
            if(!toFloat)
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no float value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_Y_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            QString strStd=imgElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_STD_COORDINATE);
            if(strStd.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_STD_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            toFloat=false;
            float std=strStd.toFloat(&toFloat);
            if(!toFloat)
            {
                strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn GCP positon %1 no float value in attribute %2 value in image position %3")
                        .arg(QString::number(nGcp+1))
                        .arg(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_STD_COORDINATE)
                        .arg(QString::number(nI+1));
                return(false);
            }
            if(mImageCoordinatesOrigin.compare(ORTOSKYXMLMATCHESFILE_IMAGE_COORDINATES_ORIGIN_LOWER_LEFT,Qt::CaseInsensitive)==0)
            {
                row=mSensorSize.height()-row;
            }
            QVector<float> imgGcp;
            imgGcp.push_back(column);imgGcp.push_back(row);imgGcp.push_back(std);
            if(mImageCoordinatesGCPs.contains(name))
            {
                if(mImageCoordinatesGCPs[name].contains(imageId))
                {
                    strError=QObject::tr("OrientationProcessMonitor::getGCPsFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nIn GCP positon %1 duplicated position in image position %2")
                            .arg(QString::number(nGcp+1))
                            .arg(QString::number(nI+1));
                    return(false);
                }
                mImageCoordinatesGCPs[name][imageId]=imgGcp;
            }
            else
            {
                QMap<QString,QVector<float> > aux;
                aux[imageId]=imgGcp;
                mImageCoordinatesGCPs[name]=aux;
            }
        }
        mGeometryGCPs[name]=geometryGcp;
        mIsControlGCPs[name]=isControl;
    }
    return(true);
}

bool OrientationProcessMonitor::getGroundControlDataForSDGAP(bool setGroundControlFixed,
                                                             QVector<QString>& includedImages,
                                                             bool writeSDGAPInputFiles,
                                                             QString &strError)
{
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
//        QFileInfo fileInfo(mXmlFileName);
//        sdgapInputFilesPath=fileInfo.absolutePath();
        sdgapInputFilesPath=mTmpFolder;
    }
    if(!mLibSDGAP->setGroundControlData(mGeometryGCPs,
                                        mIsControlGCPs,
                                        mImageCoordinatesGCPs,
                                        setGroundControlFixed,
                                        includedImages,
                                        sdgapInputFilesPath,
                                        strError))
    {
        return(false);
    }
    return(true);
}

bool OrientationProcessMonitor::writeDicoAppuis(QString& strError)
{
    /*
    QFile file(url);
    file.open(QIODevice::WriteOnly);
    QTextStream out(&file);
    out << "<?xml version=\"1.0\" ?> \n";
    out << "<Global>\n";
    out << "\t<DicoAppuisFlottant>\n";

    QList<PW3dPoint *> *controlPoints = mProject->getModelCPoints();
    for(int i= 0; i<controlPoints->count(); i++){
        PW3dPoint *point =  controlPoints->at(i);
        if(point->getCoord(0) != 0 || point->getCoord(1) != 0 || point->getCoord(2) != 0){
            out << "\t\t<OneAppuisDAF>\n";
            out << "\t\t\t<Pt>    " << QString::number(controlPoints->at(i)->getCoord(0),'f',5) << "    " <<
                   QString::number(controlPoints->at(i)->getCoord(1),'f',5) << "    " <<
                   QString::number(controlPoints->at(i)->getCoord(2),'f',5) << "</Pt>\n";
            out << "\t\t\t<NamePt>" << "    " << controlPoints->at(i)->getName() << "</NamePt>\n";
            out << "\t\t\t<Incertitude>       0.002       0.002       0.002</Incertitude>\n";  //******************TODO; Parametrizar.***********************
            out << "\t\t</OneAppuisDAF>\n";
        }
    }

    out << "\t</DicoAppuisFlottant>\n";
    out << "</Global>";
    */

    return true;
}

bool OrientationProcessMonitor::writeGCPsDataInAperoFormat(QString &strError)
{

    // Impresión del fichero con las coordenadas de los GCPs
    {
        QString fileName=mImagesPath+"/"+ORIENTATIONPROCESSMONITOR_GCPS_COORDINATES_FILE_NAME;
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text))
        {
            strError=tr("Error opening xml file:\n%1").arg(fileName);
            return(false);
        }
        QTextStream out(&file);
        out << "<?xml version=\"1.0\" ?> \n";
        out << "<Global>\n";
        out << "\t<DicoAppuisFlottant>\n";

        QMap<QString,QVector<float> >::const_iterator iter=mGeometryGCPs.begin();
        while(iter!=mGeometryGCPs.end())
        {
            QString name=iter.key();
            if(mIsControlGCPs[name])
            {
                QVector<float> geometry=iter.value();
                out << "\t\t<OneAppuisDAF>\n";
                out << "\t\t\t<Pt>    " << QString::number(geometry[0],'f',5) << "    "
                                        << QString::number(geometry[1],'f',5) << "    "
                                        << QString::number(geometry[2],'f',5) << "</Pt>\n";
                out << "\t\t\t<NamePt>" << "    " << name << "</NamePt>\n";
                out << "\t\t\t<Incertitude>       " << QString::number(geometry[3],'f',5) << "    "
                                                    << QString::number(geometry[4],'f',5) << "    "
                                                    << QString::number(geometry[5],'f',5) << " </Incertitude>\n";
                out << "\t\t</OneAppuisDAF>\n";
            }
            iter++;
        }
        out << "\t</DicoAppuisFlottant>\n";
        out << "</Global>";
        file.close();
        addFileToRemove(fileName);
    }

    // Impresión del fichero con las medidas en las imágenes de los GCPs
    {
        QString fileName=mImagesPath+"/"+ORIENTATIONPROCESSMONITOR_GCPS_IMAGE_MEASUREMENTS_FILE_NAME;
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text))
        {
            strError=tr("Error opening xml file:\n%1").arg(fileName);
            return(false);
        }
        QTextStream out(&file);
        out << "<?xml version=\"1.0\" ?> \n";
        out << "<SetOfMesureAppuisFlottants>\n";
        for (int i = 0; i< mImages.count(); i++)
        {
            QString imageId=mImages[i]->getFileName();
            bool existsMeasurements=false;
            QMap<QString,QMap<QString,QVector<float> > >::const_iterator iter1=mImageCoordinatesGCPs.begin();
            while(iter1!=mImageCoordinatesGCPs.end())
            {
                if(iter1.value().contains(imageId)
                        &&mIsControlGCPs[iter1.key()])
                {
                    existsMeasurements=true;
                    break;
                }
                iter1++;
            }
            if(existsMeasurements)
            {
                out << "\t<MesureAppuiFlottant1Im>\n";
                out << "\t\t<NameIm>" << imageId << "</NameIm>\n";
                iter1=mImageCoordinatesGCPs.begin();
                while(iter1!=mImageCoordinatesGCPs.end())
                {
                    if(iter1.value().contains(imageId))
                    {
                        QString gcpName=iter1.key();
                        if(mIsControlGCPs[gcpName])
                        {
                            QVector<float> values=iter1.value()[imageId];
                            out << "\t\t\t<OneMesureAF1I>\n";
                            out << "\t\t\t\t<NamePt>" << gcpName << "</NamePt>\n";
                            out << "\t\t\t\t<PtIm> " << QString::number(values[0],'f',mImageCoordinatesPrecision) <<
                                   " "<< QString::number(values[1],'f',mImageCoordinatesPrecision)<< "</PtIm>\n";
                            out << "\t\t\t</OneMesureAF1I>\n";
                        }
                    }
                    iter1++;
                }
                out << "\t</MesureAppuiFlottant1Im>\n";
            }
            addFileToRemove(fileName);
        }
        out << "</SetOfMesureAppuisFlottants>";
        file.close();
    }
    return(true);
}

bool OrientationProcessMonitor::writeGCPsDataInAperoFormatFromXmlOrtoSky(QString &strError)
{

    // Impresión del fichero con las coordenadas de los GCPs
    {
        QString fileName=mTmpFolder+"/"+ORIENTATIONPROCESSMONITOR_GCPS_COORDINATES_FILE_NAME;
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text))
        {
            strError=tr("Error opening xml file:\n%1").arg(fileName);
            return(false);
        }
        QTextStream out(&file);
        out << "<?xml version=\"1.0\" ?> \n";
        out << "<Global>\n";
        out << "\t<DicoAppuisFlottant>\n";

        QMap<QString,QVector<float> >::const_iterator iter=mGeometryGCPs.begin();
        while(iter!=mGeometryGCPs.end())
        {
            QString name=iter.key();
            if(mIsControlGCPs[name])
            {
                QVector<float> geometry=iter.value();
                out << "\t\t<OneAppuisDAF>\n";
                out << "\t\t\t<Pt>    " << QString::number(geometry[0],'f',5) << "    "
                                        << QString::number(geometry[1],'f',5) << "    "
                                        << QString::number(geometry[2],'f',5) << "</Pt>\n";
                out << "\t\t\t<NamePt>" << "    " << name << "</NamePt>\n";
                out << "\t\t\t<Incertitude>       " << QString::number(geometry[3],'f',5) << "    "
                                                    << QString::number(geometry[4],'f',5) << "    "
                                                    << QString::number(geometry[5],'f',5) << " </Incertitude>\n";
                out << "\t\t</OneAppuisDAF>\n";
            }
            iter++;
        }
        out << "\t</DicoAppuisFlottant>\n";
        out << "</Global>";
        file.close();
        addFileToRemove(fileName);
    }

    // Impresión del fichero con las medidas en las imágenes de los GCPs
    {
        QString fileName=mTmpFolder+"/"+ORIENTATIONPROCESSMONITOR_GCPS_IMAGE_MEASUREMENTS_FILE_NAME;
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text))
        {
            strError=tr("Error opening xml file:\n%1").arg(fileName);
            return(false);
        }
        QTextStream out(&file);
        out << "<?xml version=\"1.0\" ?> \n";
        out << "<SetOfMesureAppuisFlottants>\n";
//        for (int i = 0; i< mImages.count(); i++)
        for (int i = 0; i< mImageNames.count(); i++)
        {
            QString imageId=mImageNames[i];
            QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageId];
//            QString imageId=mImages[i]->getFileName();
            bool existsMeasurements=false;
            QMap<QString,QMap<QString,QVector<float> > >::const_iterator iter1=mImageCoordinatesGCPs.begin();
            while(iter1!=mImageCoordinatesGCPs.end())
            {
                if(iter1.value().contains(imageId)
                        &&mIsControlGCPs[iter1.key()])
                {
                    existsMeasurements=true;
                    break;
                }
                iter1++;
            }
            if(existsMeasurements)
            {
                out << "\t<MesureAppuiFlottant1Im>\n";
                out << "\t\t<NameIm>" << imageFileNameWithoutPath << "</NameIm>\n";
                iter1=mImageCoordinatesGCPs.begin();
                while(iter1!=mImageCoordinatesGCPs.end())
                {
                    if(iter1.value().contains(imageId))
                    {
                        QString gcpName=iter1.key();
                        if(mIsControlGCPs[gcpName])
                        {
                            QVector<float> values=iter1.value()[imageId];
                            out << "\t\t\t<OneMesureAF1I>\n";
                            out << "\t\t\t\t<NamePt>" << gcpName << "</NamePt>\n";
                            out << "\t\t\t\t<PtIm> " << QString::number(values[0],'f',mImageCoordinatesPrecision) <<
                                   " "<< QString::number(values[1],'f',mImageCoordinatesPrecision)<< "</PtIm>\n";
                            out << "\t\t\t</OneMesureAF1I>\n";
                        }
                    }
                    iter1++;
                }
                out << "\t</MesureAppuiFlottant1Im>\n";
            }
            addFileToRemove(fileName);
        }
        out << "</SetOfMesureAppuisFlottants>";
        file.close();
    }
    return(true);
}

bool OrientationProcessMonitor::writeMesureAppuis(QString& strError)
{
    /*
    //Mapping zerro model points:
    QList<PW3dPoint *> *controlPoints = mProject->getModelCPoints();
    QMap<QString, PW3dPoint *> zeroPoints;
    for(int i= 0; i<controlPoints->count(); i++){
        PW3dPoint *point =  controlPoints->at(i);
        if(point->getCoord(0) == 0 && point->getCoord(1) == 0 && point->getCoord(2) == 0){
            zeroPoints.insert(point->getName(),point);
        }
    }

    QFile file(url);
    file.open(QIODevice::WriteOnly);
    QTextStream out(&file);
    out << "<?xml version=\"1.0\" ?> \n";
    out << "<SetOfMesureAppuisFlottants>\n";
    QList<PW::PWImage *> images = mProject->getImages();
    for (int i = 0; i< images.count(); i++){
        out << "\t<MesureAppuiFlottant1Im>\n";
        out << "\t\t<NameIm>" << images.at(i)->getFileName() << "</NameIm>\n";
        for (int p = 0; p< images.at(i)->getControlPoints()->count(); p++){
            if(!zeroPoints.contains(images.at(i)->getControlPoints()->at(p)->getName())){
                out << "\t\t\t<OneMesureAF1I>\n";
                out << "\t\t\t\t<NamePt>" << images.at(i)->getControlPoints()->at(p)->getName() << "</NamePt>\n";
                out << "\t\t\t\t<PtIm> " << images.at(i)->getControlPoints()->at(p)->getCoord(0) <<
                       " "<< images.at(i)->getControlPoints()->at(p)->getCoord(1) << "</PtIm>\n";
                out << "\t\t\t</OneMesureAF1I>\n";
            }
        }
        out << "\t</MesureAppuiFlottant1Im>\n";
    }
    out << "</SetOfMesureAppuisFlottants>";
    */
    return(true);
}

void OrientationProcessMonitor::getImagesIdsTiePoints(QMap<QString, QVector<QString> > &imagesIdsTiePoints)
{
    imagesIdsTiePoints=mImagesIdsTiePoints;
}

bool OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile(QVector<QString> &orientationImagesIds,
                                                             QString &strError)
{
    orientationImagesIds.clear();
    //mImagesIds.clear();
    mImagesFirstColumnsTiePoints.clear();
    mImagesFirstRowsTiePoints.clear();
    mImagesSecondColumnsTiePoints.clear();
    mImagesSecondRowsTiePoints.clear();
    mMatchesIds.clear();
    mAccuraciesByMatchId.clear();
    mMatchesAccuracies.clear();
    mMatchesTerrainCoordinates.clear();
    mMatchesAccuraciesTerrainCoordinates.clear();

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Lectura de los TiePoints de los pares
    QDomNodeList pairsNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
    if(pairsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag pairs in session %1").arg(mSessionName);
        return(false);
    }
    if(pairsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one pairs node in session %1").arg(mSessionName);
        return(false);
    }
    QDomNode pairsNode=pairsNodes.at(0);
    QDomElement pairsElement=pairsNode.toElement();
    QDomNodeList pairNodes=pairsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR);
    if(pairNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nIn node pairs must be one pair node at least");
        return(false);
    }
    bool existsAccuracy=false;
    for(int nPairNode=0;nPairNode<pairNodes.size();nPairNode++)
    {
        QDomNode pairNode=pairNodes.at(nPairNode);
        if(!pairNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nPair node number %1 is not an element").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement pairElement=pairNode.toElement();

        QDomNodeList image1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_IMAGE1);
        if(image1DataNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there is not a image1 node").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement image1Element=image1DataNodes.at(0).toElement();
        QString image1Name=image1Element.text().trimmed();
        if(!mImageNames.contains(image1Name))
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, image1 value %1 is not exists").arg(QString::number(nPairNode+1)).arg(image1Name);
            return(false);
        }

        QDomNodeList image2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_IMAGE2);
        if(image2DataNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there is not a image2 node").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement image2Element=image2DataNodes.at(0).toElement();
        QString image2Name=image2Element.text().trimmed();
        if(!mImageNames.contains(image2Name))
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, image2 value %1 is not exists").arg(QString::number(nPairNode+1)).arg(image2Name);
            return(false);
        }

        if(!mImagePairsByName.contains(image1Name))
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, image1=%2 is not in mImagePairsByName").arg(QString::number(nPairNode+1)).arg(image1Name);
            return(false);
        }
        if(!mImagePairsByName[image1Name].contains(image2Name))
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, image2=%2 is not in mImagePairsByName for image1=%3").arg(QString::number(nPairNode+1)).arg(image2Name).arg(image1Name);
            return(false);
        }
        QDomNodeList pointsDataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINTS);
        if(pointsDataNodes.size()>1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there are more than one points node").arg(QString::number(nPairNode+1));
            return(false);
        }
        if(pointsDataNodes.size()==0) // De esta forma no figuran pares sin puntos
            continue;

        QDomElement pointsElement=pointsDataNodes.at(0).toElement();
        QDomNodeList pntsDataNodes=pointsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINT);
        if(pntsDataNodes.size()<3)
        {
            continue;
//            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(fileName);
//            strError+=QObject::tr("\nIn pair node number %1, the number of matches is less than tree").arg(QString::number(nPairNode+1));
//            return(false);
        }

        if(!orientationImagesIds.contains(image1Name))
            orientationImagesIds.push_back(image1Name);
        if(!orientationImagesIds.contains(image2Name))
            orientationImagesIds.push_back(image2Name);

        QString camera1Name=mImageCamerasByName[image1Name];
        QString camera2Name=mImageCamerasByName[image2Name];
        if(camera1Name.compare(camera2Name,Qt::CaseInsensitive)!=0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, images have different camera").arg(QString::number(nPairNode+1));
            return(false);
        }
        QString cameraName=camera1Name;

        QVector<float> orientationImageFirstColumns;
        QVector<float> orientationImageFirstRows;
        QVector<float> orientationImageSecondColumns;
        QVector<float> orientationImageRowColumns;
        QVector<int> matchIds;
        QVector<float> orientationAccuracies;
        for(int nPnt=0;nPnt<pntsDataNodes.size();nPnt++)
        {
            QDomNode pntNode=pntsDataNodes.at(nPnt);
            if(!pntNode.isElement())
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 is not an element").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QDomElement pntElement=pntNode.toElement();
            QString strColumn1=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_X1_COORDINATE).trimmed();
            if(strColumn1.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found column1 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strRow1=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_Y1_COORDINATE).trimmed();
            if(strRow1.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found row1 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strColumn2=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_X2_COORDINATE).trimmed();
            if(strColumn2.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found column2 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strRow2=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_Y2_COORDINATE).trimmed();
            if(strRow2.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found row2 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strAccuracy=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_ACCURACY).trimmed();
            float accuracy;
            if(strAccuracy.isEmpty()&&existsAccuracy)
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found std attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            else
            {
                if(!strAccuracy.isEmpty())
                {
                    accuracy=strAccuracy.toFloat();
                    existsAccuracy=true;
                }
            }
            float column1=strColumn1.toFloat();
            float row1=strRow1.toFloat();
            float column2=strColumn2.toFloat();
            float row2=strRow2.toFloat();
            if(mImageCoordinatesOrigins[cameraName].compare(ORTOSKYXMLMATCHESFILE_IMAGE_COORDINATES_ORIGIN_LOWER_LEFT,Qt::CaseInsensitive)==0)
            {
                row1=mSensorSizes[cameraName].height()-row1;
                row2=mSensorSizes[cameraName].height()-row2;
//                firstImagePixelsRow[nPoint]=mSensorSize.height()-firstImagePixelsRow[nPoint];
//                secondImagePixelsRow[nPoint]=mSensorSize.height()-secondImagePixelsRow[nPoint];
            }
            matchIds.push_back(nPnt);
            orientationImageFirstColumns.push_back(column1);
            orientationImageFirstRows.push_back(row1);
            orientationImageSecondColumns.push_back(column2);
            orientationImageRowColumns.push_back(row2);
            if(existsAccuracy)
            {
                orientationAccuracies.push_back(accuracy);
                //mAccuraciesByMatchId[nPnt]=accuracy;
            }
        }
        if(!mImagesIdsTiePoints.contains(image1Name))
        {
            QVector<QString> orientationImageIdsTiePoints;
            orientationImageIdsTiePoints.push_back(image2Name);
            mImagesIdsTiePoints[image1Name]=orientationImageIdsTiePoints;
            QMap<QString,QVector<float> > orientationImageFirstColumnsTiePoints;
            QMap<QString,QVector<float> > orientationImageFirstRowsTiePoints;
            QMap<QString,QVector<float> > orientationImageSecondColumnsTiePoints;
            QMap<QString,QVector<float> > orientationImageSecondRowsTiePoints;
            QMap<QString,QVector<float> > orientationMatchesAccuracies;
            QMap<QString,QVector<int> > orientationMatchIds;
            orientationImageFirstColumnsTiePoints[image2Name]=orientationImageFirstColumns;
            orientationImageFirstRowsTiePoints[image2Name]=orientationImageFirstRows;
            orientationImageSecondColumnsTiePoints[image2Name]=orientationImageSecondColumns;
            orientationImageSecondRowsTiePoints[image2Name]=orientationImageRowColumns;
            orientationMatchIds[image2Name]=matchIds;
            if(existsAccuracy)
                orientationMatchesAccuracies[image2Name]=orientationAccuracies;
            mImagesFirstColumnsTiePoints[image1Name]=orientationImageFirstColumnsTiePoints;
            mImagesFirstRowsTiePoints[image1Name]=orientationImageFirstRowsTiePoints;
            mImagesSecondColumnsTiePoints[image1Name]=orientationImageSecondColumnsTiePoints;
            mImagesSecondRowsTiePoints[image1Name]=orientationImageSecondRowsTiePoints;
            mMatchesIds[image1Name]=orientationMatchIds;
            if(existsAccuracy)
                mMatchesAccuracies[image1Name]=orientationMatchesAccuracies;
        }
        else
        {
            if(mImagesIdsTiePoints[image1Name].contains(image2Name))
            {
                strError=QObject::tr("OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair duplicated (%1,%2)").arg(image1Name).arg(image2Name);
                return(false);
            }
            mImagesIdsTiePoints[image1Name].push_back(image2Name);
            mImagesFirstColumnsTiePoints[image1Name][image2Name]=orientationImageFirstColumns;
            mImagesFirstRowsTiePoints[image1Name][image2Name]=orientationImageFirstRows;
            mImagesSecondColumnsTiePoints[image1Name][image2Name]=orientationImageSecondColumns;
            mImagesSecondRowsTiePoints[image1Name][image2Name]=orientationImageRowColumns;
            mMatchesIds[image1Name][image2Name]=matchIds;
            if(existsAccuracy)
                mMatchesAccuracies[image1Name][image2Name]=orientationAccuracies;
        }
    }
    return(true);
}

bool OrientationProcessMonitor::getMatchesFromOrtoSkyXmlFile_201501(QMap<QString, int> &orientationImagesIds,
                                                                    QString &strError)
{
    /*
    orientationImagesIds.clear();
    mImagesIds.clear();
    mImagesFirstColumnsTiePoints.clear();
    mImagesFirstRowsTiePoints.clear();
    mImagesSecondColumnsTiePoints.clear();
    mImagesSecondRowsTiePoints.clear();
    mMatchesIds.clear();
    mAccuraciesByMatchId.clear();
    mMatchesAccuracies.clear();

    // Lectura de las imágenes
    QDomNodeList photosNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOS);
    if(photosNodes.size()==0)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag photos in the file");
        return(false);
    }
    if(photosNodes.size()>1)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one photos node");
        return(false);
    }
    QDomNode photosNode=photosNodes.at(0);
    QDomElement photosElement=photosNode.toElement();
    QDomNodeList photoNodes=photosElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTO);
    if(photoNodes.size()<2)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nIn node photos must be more than one photo nodes");
        return(false);
    }
    for(int nPhotoNode=0;nPhotoNode<photoNodes.size();nPhotoNode++)
    {
        QDomNode photoNode=photoNodes.at(nPhotoNode);
        if(!photoNode.isElement())
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nPhoto node number %1 is not an element").arg(QString::number(nPhotoNode+1));
            return(false);
        }
        QDomElement photoElement=photoNode.toElement();
        QDomNodeList resourceDataNodes=photoElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_DATASOURCE);
        if(resourceDataNodes.size()!=1)
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn photo node number %1, there is not a resource data node").arg(QString::number(nPhotoNode+1));
            return(false);
        }
        QDomElement resourceDataElement=resourceDataNodes.at(0).toElement();
        QString imageFullPathFileName=resourceDataElement.text();
        QFileInfo fileInfo(imageFullPathFileName);
        QString imageFileName=fileInfo.fileName();
        if(orientationImagesIds.contains(imageFileName))
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, in file %1 repeat image: \n %2").arg(mXmlFileName).arg(imageFullPathFileName);
            return(false);
        }
        mImagesIds[imageFileName]=nPhotoNode;
        mImagesFileNameByPos[nPhotoNode]=imageFileName;
    }

    // Lectura de los pares a procesar
    QDomNodeList pairsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
    if(pairsNodes.size()==0)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag pairs in the file");
        return(false);
    }
    if(pairsNodes.size()>1)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one pairs node");
        return(false);
    }
    QDomNode pairsNode=pairsNodes.at(0);
    QDomElement pairsElement=pairsNode.toElement();
    QDomNodeList pairNodes=pairsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR);
    if(pairNodes.size()<1)
    {
        strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nIn node pairs must be one pair node at least");
        return(false);
    }
    bool existsAccuracy=false;
    for(int nPairNode=0;nPairNode<pairNodes.size();nPairNode++)
    {
        QDomNode pairNode=pairNodes.at(nPairNode);
        if(!pairNode.isElement())
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nPair node number %1 is not an element").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement pairElement=pairNode.toElement();

        QDomNodeList photo1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO1);
        if(photo1DataNodes.size()!=1)
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there is not a photo1 node").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement photo1Element=photo1DataNodes.at(0).toElement();
        QString strPhoto1=photo1Element.text();
        bool toInt=false;
        int photo1=strPhoto1.toInt(&toInt);
        if(!toInt||photo1<0||photo1>(mImagesFileNameByPos.size()-1))
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, photo1 value %1 is not valid").arg(QString::number(nPairNode+1)).arg(strPhoto1);
            return(false);
        }

        QDomNodeList photo2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO2);
        if(photo2DataNodes.size()!=1)
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there is not a photo2 node").arg(QString::number(nPairNode+1));
            return(false);
        }
        QDomElement photo2Element=photo2DataNodes.at(0).toElement();
        QString strPhoto2=photo2Element.text();
        toInt=false;
        int photo2=strPhoto2.toInt(&toInt);
        if(!toInt||photo2<0||photo2>(mImagesFileNameByPos.size()-1))
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, photo2 value %1 is not valid").arg(QString::number(nPairNode+1)).arg(strPhoto2);
            return(false);
        }

        QString image1FileName=mImagesFileNameByPos[photo1];
        QString image2FileName=mImagesFileNameByPos[photo2];

        QDomNodeList pointsDataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINTS);
        if(pointsDataNodes.size()>1)
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn pair node number %1, there are more than one points node").arg(QString::number(nPairNode+1));
            return(false);
        }
        if(pointsDataNodes.size()==0) // De esta forma no figuran pares sin puntos
            continue;

        QDomElement pointsElement=pointsDataNodes.at(0).toElement();
        QDomNodeList pntsDataNodes=pointsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINT);
        if(pntsDataNodes.size()<3)
        {
            continue;
//            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(fileName);
//            strError+=QObject::tr("\nIn pair node number %1, the number of matches is less than tree").arg(QString::number(nPairNode+1));
//            return(false);
        }

        QVector<float> orientationImageFirstColumns;
        QVector<float> orientationImageFirstRows;
        QVector<float> orientationImageSecondColumns;
        QVector<float> orientationImageRowColumns;
        QVector<int> matchIds;
        QVector<float> orientationAccuracies;
        for(int nPnt=0;nPnt<pntsDataNodes.size();nPnt++)
        {
            QDomNode pntNode=pntsDataNodes.at(nPnt);
            if(!pntNode.isElement())
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 is not an element").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QDomElement pntElement=pntNode.toElement();
            QString strColumn1=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_X1_COORDINATE).trimmed();
            if(strColumn1.isEmpty())
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found column1 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strRow1=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_Y1_COORDINATE).trimmed();
            if(strRow1.isEmpty())
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found row1 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strColumn2=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_X2_COORDINATE).trimmed();
            if(strColumn2.isEmpty())
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found column2 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strRow2=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_Y2_COORDINATE).trimmed();
            if(strRow2.isEmpty())
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found row2 attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            QString strAccuracy=pntElement.attribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_ACCURACY).trimmed();
            float accuracy;
            if(strAccuracy.isEmpty()&&existsAccuracy)
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair node number %1, point number %2 not found std attribute").arg(QString::number(nPairNode+1)).arg(QString::number(nPnt));
                return(false);
            }
            else
            {
                if(!strAccuracy.isEmpty())
                {
                    accuracy=strAccuracy.toFloat();
                    existsAccuracy=true;
                }
            }
            float column1=strColumn1.toFloat();
            float row1=strRow1.toFloat();
            float column2=strColumn2.toFloat();
            float row2=strRow2.toFloat();
            if(mImageCoordinatesOrigin.compare(ORTOSKYXMLMATCHESFILE_IMAGE_COORDINATES_ORIGIN_LOWER_LEFT,Qt::CaseInsensitive)==0)
            {
                row1=mSensorSize.height()-row1;
                row2=mSensorSize.height()-row2;
//                firstImagePixelsRow[nPoint]=mSensorSize.height()-firstImagePixelsRow[nPoint];
//                secondImagePixelsRow[nPoint]=mSensorSize.height()-secondImagePixelsRow[nPoint];
            }
            matchIds.push_back(nPnt);
            orientationImageFirstColumns.push_back(column1);
            orientationImageFirstRows.push_back(row1);
            orientationImageSecondColumns.push_back(column2);
            orientationImageRowColumns.push_back(row2);
            if(existsAccuracy)
            {
                orientationAccuracies.push_back(accuracy);
                //mAccuraciesByMatchId[nPnt]=accuracy;
            }
        }
        if(!mImagesIdsTiePoints.contains(image1FileName))
        {
            QVector<QString> orientationImageIdsTiePoints;
            orientationImageIdsTiePoints.push_back(image2FileName);
            mImagesIdsTiePoints[image1FileName]=orientationImageIdsTiePoints;
            QMap<QString,QVector<float> > orientationImageFirstColumnsTiePoints;
            QMap<QString,QVector<float> > orientationImageFirstRowsTiePoints;
            QMap<QString,QVector<float> > orientationImageSecondColumnsTiePoints;
            QMap<QString,QVector<float> > orientationImageSecondRowsTiePoints;
            QMap<QString,QVector<float> > orientationMatchesAccuracies;
            QMap<QString,QVector<int> > orientationMatchIds;
            orientationImageFirstColumnsTiePoints[image2FileName]=orientationImageFirstColumns;
            orientationImageFirstRowsTiePoints[image2FileName]=orientationImageFirstRows;
            orientationImageSecondColumnsTiePoints[image2FileName]=orientationImageSecondColumns;
            orientationImageSecondRowsTiePoints[image2FileName]=orientationImageRowColumns;
            orientationMatchIds[image2FileName]=matchIds;
            if(existsAccuracy)
                orientationMatchesAccuracies[image2FileName]=orientationAccuracies;
            mImagesFirstColumnsTiePoints[image1FileName]=orientationImageFirstColumnsTiePoints;
            mImagesFirstRowsTiePoints[image1FileName]=orientationImageFirstRowsTiePoints;
            mImagesSecondColumnsTiePoints[image1FileName]=orientationImageSecondColumnsTiePoints;
            mImagesSecondRowsTiePoints[image1FileName]=orientationImageSecondRowsTiePoints;
            mMatchesIds[image1FileName]=orientationMatchIds;
            if(existsAccuracy)
                mMatchesAccuracies[image1FileName]=orientationMatchesAccuracies;
        }
        else
        {
            if(mImagesIdsTiePoints[image1FileName].contains(image2FileName))
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nPair duplicated (%1,%2)").arg(QString::number(photo1)).arg(QString::number(photo2));
                return(false);
            }
            mImagesIdsTiePoints[image1FileName].push_back(image2FileName);
            mImagesFirstColumnsTiePoints[image1FileName][image2FileName]=orientationImageFirstColumns;
            mImagesFirstRowsTiePoints[image1FileName][image2FileName]=orientationImageFirstRows;
            mImagesSecondColumnsTiePoints[image1FileName][image2FileName]=orientationImageSecondColumns;
            mImagesSecondRowsTiePoints[image1FileName][image2FileName]=orientationImageRowColumns;
            mMatchesIds[image1FileName][image2FileName]=matchIds;
            if(existsAccuracy)
                mMatchesAccuracies[image1FileName][image2FileName]=orientationAccuracies;
        }
    }
    orientationImagesIds=mImagesIds;
    */
    return(true);
}

bool OrientationProcessMonitor::getWithSourceOrientation()
{
    if(mSourceOrientation.compare(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION_NO_INPUT,Qt::CaseInsensitive)==0)
        return(false);
    return(true);
}

bool OrientationProcessMonitor::initializeCalibrationModels(QString& strError)
{
    QString noDGAPid;
    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_FRASER_BASIC]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_FRASER_BASIC,
                                                                               PBA_CALIBRATION_MODEL_DGAP_ID_FRASER_BASIC,
                                                                               PBA_CALIBRATION_MODEL_EXPLAIN_FRASER_BASIC,
                                                                               PBA_CALIBRATION_MODEL_ID_FRASER_BASIC);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_IMAGE_MASTER]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_IMAGE_MASTER,
                                                                                  PBA_CALIBRATION_MODEL_DGAP_ID_IMAGE_MASTER,
                                                                               PBA_CALIBRATION_MODEL_EXPLAIN_IMAGE_MASTER,
                                                                               PBA_CALIBRATION_MODEL_ID_IMAGE_MASTER);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_REFINE]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_REFINE,
                                                                            noDGAPid,
                                                                         PBA_CALIBRATION_MODEL_EXPLAIN_REFINE,
                                                                         PBA_CALIBRATION_MODEL_ID_REFINE);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_FIXED]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_FIXED,
                                                                           noDGAPid,
                                                                        PBA_CALIBRATION_MODEL_EXPLAIN_FIXED,
                                                                        PBA_CALIBRATION_MODEL_ID_FIXED);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_SDGAP_AUSTRALIS]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_SDGAP_AUSTRALIS,
                                                                                     PBA_CALIBRATION_MODEL_DGAP_ID_SDGAP_AUSTRALIS,
                                                                        PBA_CALIBRATION_MODEL_EXPLAIN_SDGAP_AUSTRALIS,
                                                                        PBA_CALIBRATION_MODEL_ID_SDGAP_AUSTRALIS);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_SDGAP_AUSTRALIS_FIXED]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_SDGAP_AUSTRALIS_FIXED,
                                                                                     PBA_CALIBRATION_MODEL_DGAP_ID_SDGAP_AUSTRALIS_FIXED,
                                                                        PBA_CALIBRATION_MODEL_EXPLAIN_SDGAP_AUSTRALIS_FIXED,
                                                                        PBA_CALIBRATION_MODEL_ID_SDGAP_AUSTRALIS_FIXED);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_SDGAP_IRD]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_SDGAP_IRD,
                                                                               PBA_CALIBRATION_MODEL_DGAP_ID_SDGAP_IRD,
                                                                        PBA_CALIBRATION_MODEL_EXPLAIN_SDGAP_IRD,
                                                                        PBA_CALIBRATION_MODEL_ID_SDGAP_IRD);

    mPBACalibrationModels[PBA_CALIBRATION_MODEL_ID_SDGAP_IRD_FIXED]=new PBACalibrationModel(PBA_CALIBRATION_MODEL_APERO_ID_SDGAP_IRD_FIXED,
                                                                               PBA_CALIBRATION_MODEL_DGAP_ID_SDGAP_IRD_FIXED,
                                                                        PBA_CALIBRATION_MODEL_EXPLAIN_SDGAP_IRD_FIXED,
                                                                        PBA_CALIBRATION_MODEL_ID_SDGAP_IRD_FIXED);
    return(true);
}

bool OrientationProcessMonitor::initializeSDGAP(QString sdgapPath,
                                                bool writeSDGAPInputFiles,
                                                QString &strError)
{
    if(mLibSDGAP!=NULL)
        delete(mLibSDGAP);
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
//        sdgapInputFilesPath=mProjectPath;
        sdgapInputFilesPath=mTmpFolder;
    }
//    mLibSDGAP=new LibSDGAP(mImageCoordinatesPrecision,mProjectPath);
    mLibSDGAP=new LibSDGAP(mImageCoordinatesPrecision,mTmpFolder);
    if(!mLibSDGAP->setDefaultValues(sdgapPath,
                                    sdgapInputFilesPath,
                                    strError))
        return(false);
    return(true);
}

bool OrientationProcessMonitor::getInputOrientationDataForSDGAP(QVector<QString>& includedImages,
                                                                bool writeSDGAPInputFiles,
                                                                QString &strError)
{
    //QString calibrationId=mSourceOrientation;
    QString dgapId=mPBACalibrationModel->getDGAPId();
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
//        sdgapInputFilesPath=mProjectPath;
        sdgapInputFilesPath=mTmpFolder;
    }
    if(dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS,Qt::CaseInsensitive)!=0
            &&dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_IRD,Qt::CaseInsensitive)!=0
            &&dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_FIXED,Qt::CaseInsensitive)!=0
            &&dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_IRD_FIXED,Qt::CaseInsensitive)!=0)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, invalid dgap id: %1").arg(dgapId);
        return(false);
    }

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Almacenamiento de las orientaciones en las imágenes
    QDomNodeList imagesNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGES);
    if(imagesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag images in the session name %1").arg(mSessionName);
        return(false);
    }
    if(imagesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one images node in session name %1").arg(mSessionName);
        return(false);
    }
    QDomNode imagesNode=imagesNodes.at(0);
    QDomElement imagesElement=imagesNode.toElement();
    QDomNodeList imageNodes=imagesElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE);
    if(imageNodes.size()<2)
    {
        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
        strError+=QObject::tr("\nIn node images must be more than one image nodes");
        return(false);
    }
    QString sourceInOrientations;
    for(int nImageNode=0;nImageNode<imageNodes.size();nImageNode++)
    {
        QDomNode imageNode=imageNodes.at(nImageNode);
        if(!imageNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("Image node number %1 is not an element").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageElement=imageNode.toElement();
        QDomNodeList imageNameNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_NAME);
        if(imageNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a name node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageNameElement=imageNameNodes.at(0).toElement();
        QString imageName=imageNameElement.text().trimmed();
        QString imageId=imageName;
        if(!mImageNames.contains(imageName))
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, image name %2 is not valid").arg(QString::number(nImageNode+1)).arg(imageName);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageName];
        QDomNodeList shotNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_SHOT);
        if(shotNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a shot node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement shotElement=shotNodes.at(0).toElement();
        QDomNodeList orientationsNodes=shotElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        if(orientationsNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there are not one orientations node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement orientationsElement=orientationsNodes.at(0).toElement();
        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QDomElement orientationElement;
        QDomNode imageOrientationNode;
        bool findOrientation=false;
        for(int nC=0;nC<orientationNodes.size();nC++)
        {
            QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
            QString strName=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
            if(strName.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                strError+=QObject::tr("\nIn image node number %1, not found name attribute").arg(QString::number(nImageNode+1));
                return(false);
            }
            if(strName.compare(mSourceOrientation)==0)
            {
                orientationElement=auxOrientationElement;
                QDomNodeList auxNodes=orientationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                if(auxNodes.size()!=1)
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                    strError+=QObject::tr("\nIn image node number %1, not found tag %2")
                            .arg(QString::number(nImageNode+1)).arg(APERO_XMLFILES_TAG_EXPORT_APERO);
                    return(false);
                }
                imageOrientationNode=auxNodes.at(0);
                findOrientation=true;
                break;
            }
        }
        if(!findOrientation)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, not found orientation %2")
                    .arg(QString::number(nImageNode+1))
                    .arg(mSourceOrientation);
            return(false);
        }
        QString sourceInOrientation=orientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_CALIBRATION).trimmed();
        if(sourceInOrientation.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, in orientation %2 not found calibration attribute")
                    .arg(QString::number(nImageNode+1))
                    .arg(mSourceOrientation);
            return(false);
        }
        if(sourceInOrientations.isEmpty())
            sourceInOrientations=sourceInOrientation;
        else
        {
            if(sourceInOrientation.compare(sourceInOrientations)!=0)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                strError+=QObject::tr("\nIn image node number %1, in orientation %2 calibration attribute is differente from previous images")
                        .arg(QString::number(nImageNode+1))
                        .arg(mSourceOrientation);
                return(false);
            }
        }
    }
    mSourceCalibration=sourceInOrientations;

    // Orientación interna y parámetros adicionales
    {                       
        // Grabación de la información de la calibración de la cámara
        QDomNodeList camerasNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCES);
        if(camerasNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nShould be only one node cameras");
            return(false);
        }
        QDomNode camerasNode=camerasNodes.at(0);
        QDomElement camerasElement=camerasNode.toElement();

        // Lectura de la información de la cámara
        QDomNodeList cameraNodes=camerasElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE);
        if(cameraNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo tag camera in the file");
            return(false);
        }
        QDomNode cameraNode;
        bool findCamera=false;
        for(int nCamera=0;nCamera<cameraNodes.size();nCamera++)
        {
            QDomNode auxCameraNode=cameraNodes.at(nCamera);
            QDomElement cameraElement=auxCameraNode.toElement();

            // Lectura del nombre de la cámara
            QDomNodeList cameraNameNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CAMERA_NAME);
            if(cameraNameNodes.size()!=1)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading camera node number %1").arg(QString::number(nCamera+1));
                strError+=QObject::tr("\nCamera name node is not unique");
                return(false);
            }
            QDomNode cameraNameNode=cameraNameNodes.at(0);
            QString cameraName=cameraNameNode.toElement().text().trimmed();
            if(cameraName.compare(mCameraName,Qt::CaseInsensitive)==0)
            {
                findCamera=true;
                cameraNode=auxCameraNode;
            }
        }
        if(!findCamera)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo camera %1 in the file").arg(mCameraName);
            return(false);
        }
        QDomElement cameraElement=cameraNode.toElement();

        QDomNodeList calibrationsNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
        QDomElement calibrationsElement;
        if(calibrationsNodes.size()>1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere are more than one calibrations nodes in camera node");
            return(false);
        }
        else if(calibrationsNodes.size()==1)
        {
            calibrationsElement=calibrationsNodes.at(0).toElement();
        }
        else if(calibrationsNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere is not any calibrations nodes in camera node");
            return(false);
        }
        QDomNodeList calibrationNodes=calibrationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
        QDomElement calibrationElement;
        QDomNode calibrationNode;
        bool findCalibration=false;
        if(calibrationNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere is not any calibration nodes in camera node");
            return(false);
        }
        else
        {
            for(int nC=0;nC<calibrationNodes.size();nC++)
            {
                QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
                QString strId=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME).trimmed();
                QString calibrationEngine=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE);
                if(strId.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nCalibration node number %1, not found id attribute").arg(QString::number(nC+1));
                    return(false);
                }
                if(strId.compare(mSourceCalibration,Qt::CaseInsensitive)==0)
                {
                    calibrationElement=auxCalibrationElement;
                    QDomNodeList auxNodes=auxCalibrationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                    calibrationNode=auxNodes.at(0);
                    QDomNode clonedNode=calibrationNodes.at(nC).cloneNode();
                    findCalibration=true;
                    mInputCalibrationXmlElement=clonedNode.toElement();
                    break;
                }
            }
        }
        if(!findCalibration)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nCalibration %1 not found").arg(mSourceCalibration);
            return(false);
        }
        double previous_focal_pixel=0.0;
        double previous_xPPAFromCenter_pixel=0.0;
        double previous_yPPAFromCenter_pixel=0.0;
        bool use_previous_calibration=false;
        QDomElement calibration=calibrationNode.toElement();
        if(mCalibrationModelId.compare(PBA_CALIBRATION_MODEL_ID_SDGAP_AUSTRALIS_FIXED)==0
                ||mCalibrationModelId.compare(PBA_CALIBRATION_MODEL_ID_SDGAP_IRD_FIXED)==0)
        {
            QString previousCalibrationId=mInputCalibrationXmlElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_SOURCE_CALIBRATION_ID);
            bool findPreviousCalibration=false;
            for(int nC=0;nC<calibrationNodes.size();nC++)
            {
                QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
                QString strId=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME).trimmed();
//                QString calibrationEngine=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE);
                if(strId.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nCalibration node number %1, not found id attribute").arg(QString::number(nC+1));
                    return(false);
                }
                if(strId.compare(previousCalibrationId)==0)
                {
                    QDomNodeList auxNodes=auxCalibrationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                    QDomElement previous_calibrationElement=auxNodes.at(0).toElement();
                    use_previous_calibration=true;
                    Camera *previous_camera = mImages.at(0)->getCamera();
                    AperoModelReader previous_interiorReader(previous_camera);
                    CameraModel *previous_cameraModel = previous_interiorReader.read(previous_calibrationElement);
                    if (previous_cameraModel == NULL)
                    {
                        strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error reading interior orientation id:\n%1").arg(previousCalibrationId);
                        return(false);
                    }
                    previous_focal_pixel=((PhotogrammetricModel*)previous_cameraModel)->getFocal();
                    previous_xPPAFromCenter_pixel=((PhotogrammetricModel*)previous_cameraModel)->getXp();
                    previous_yPPAFromCenter_pixel=((PhotogrammetricModel*)previous_cameraModel)->getYp();
                    findPreviousCalibration=true;
                    break;
                }
            }
            if(!findPreviousCalibration)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nSource calibration %1 not found for input calibration %2").arg(previousCalibrationId).arg(mSourceCalibration);
                return(false);
            }
        }

        QString calibrationEngine=mInputCalibrationXmlElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE);
        bool isDGAPSourceCalibration=false;
        if(calibrationEngine.compare(PBA_COMPUTATIONS_ENGINE_SDGAP,Qt::CaseInsensitive)==0)
            isDGAPSourceCalibration=true;
        Camera *camera = mImages.at(0)->getCamera();
        AperoModelReader interiorReader(camera);
        CameraModel *cameraModel = interiorReader.read(calibration);
        if (cameraModel == NULL)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error reading interior orientation id:\n%1").arg(mSourceCalibration);
            return(false);
        }
        // Para que tras el ajuste se pueda actualizar para poder actualizar despues las precisiones
        camera->setCameraModel(cameraModel);
        for(int nII=1;nII<mImages.size();nII++)
        {
            mImages.at(nII)->getCamera()->setCameraModel(cameraModel);
        }
        QString cameraType=LIBSDGAP_CAMERA_TYPE_CCD;
        //QString cameraId=camera->getName()+"_"+calibrationId;
        QString cameraId=camera->getName();
        QString cameraComment=camera->getName();
        int columns=mSensorSize.width();
        int rows=mSensorSize.height();
        double xPixelSize_mm=camera->getSensorWidth()/((double)columns); // en mm
        double yPixelSize_mm=camera->getSensorHeight()/((double)rows); // en mm
        double focal_mm=((PhotogrammetricModel*)cameraModel)->getFocal(); // en pixel
        focal_mm*=xPixelSize_mm;
        double xPPAFromCenter_mm=((PhotogrammetricModel*)cameraModel)->getXp(); // en pixel
        xPPAFromCenter_mm=(xPPAFromCenter_mm-((double)columns)/2.0)*xPixelSize_mm;
        double yPPAFromCenter_mm=((PhotogrammetricModel*)cameraModel)->getYp(); // en pixel
        yPPAFromCenter_mm=(((double)rows)/2.0-yPPAFromCenter_mm)*xPixelSize_mm;
        double xPixelSize_mc=xPixelSize_mm*1e+3;
        double yPixelSize_mc=yPixelSize_mm*1e+3;
        double diff_focal_m=0.0;
        double diff_xPPA_m=0.0;
        double diff_yPPA_m=0.0;
        if(use_previous_calibration)
        {
            double previous_focal_mm=previous_focal_pixel*xPixelSize_mm;
            double previous_xPPAFromCenter_mm=(previous_xPPAFromCenter_pixel-((double)columns)/2.0)*xPixelSize_mm;
            double previous_yPPAFromCenter_mm=(((double)rows)/2.0-previous_yPPAFromCenter_pixel)*xPixelSize_mm;
            diff_focal_m=(focal_mm-previous_focal_mm)/1000.0;
            diff_xPPA_m=(xPPAFromCenter_mm-previous_xPPAFromCenter_mm)/1000.0;
            diff_yPPA_m=(yPPAFromCenter_mm-previous_yPPAFromCenter_mm)/1000.0;
            focal_mm=previous_focal_mm;
            xPPAFromCenter_mm=previous_xPPAFromCenter_mm;
            yPPAFromCenter_mm=previous_yPPAFromCenter_mm;
        }
        double k1_pixel=0.0;
        double k2_pixel=0.0;
        double k3_pixel=0.0;
        double p1_pixel=0.0;
        double p2_pixel=0.0;
        double b1_pixel=0.0;
        double b2_pixel=0.0;
        PW::FraserModel *distortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
        if(!distortionModel->isBasic())
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, orientation input is not Fraser basic:\n%1").arg(mSourceCalibration);
            return(false);
        }
        bool findDistortionModel=false;
        if(distortionModel!=NULL)
        {
            k1_pixel=distortionModel->getK1();
            k2_pixel=distortionModel->getK2();
            k3_pixel=distortionModel->getK3();
            p1_pixel=distortionModel->getP1();
            p2_pixel=distortionModel->getP2();
            b1_pixel=distortionModel->getB1();
            b2_pixel=distortionModel->getB2();
            findDistortionModel=true;
        }
        /*
        else
        {
            PW::RadialExtended *distortionModel = dynamic_cast<PW::RadialExtended*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
            if(distortionModel!=NULL)
            {
                k1_pixel=distortionModel->getK1();
                k2_pixel=distortionModel->getK2();
                k3_pixel=distortionModel->getK3();
                findDistortionModel=true;
            }
            else
            {
                PW::RadialBasic *distortionModel = dynamic_cast<PW::RadialBasic*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
                if(distortionModel!=NULL)
                {
                    k1_pixel=distortionModel->getK1();
                    k2_pixel=distortionModel->getK2();
                    //k3_pixel=distortionModel->getK3();
                    findDistortionModel=true;
                }
            }
        }
        */
        if(!findDistortionModel)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, distortion model not found in interior orientation id:\n%1").arg(mSourceCalibration);
            return(false);
        }
        double k1_mm=k1_pixel/pow(xPixelSize_mm,2.0)/pow(xPixelSize_mm,2.0);
        double k2_mm=k2_pixel/pow(xPixelSize_mm,4.0)/pow(xPixelSize_mm,4.0);
        double k3_mm=k3_pixel/pow(xPixelSize_mm,6.0)/pow(xPixelSize_mm,6.0);
        double p1_mm=p1_pixel/xPixelSize_mm/xPixelSize_mm;
        double p2_mm=p2_pixel/xPixelSize_mm/xPixelSize_mm;
        double b1_mm=0.0;//b1_pixel/xPixelSize_mm;
        double b2_mm=0.0;//-1.0*b2_pixel/xPixelSize_mm;
//        double k1_m=k1_mm/1.0e+6;
//        double k2_m=k2_mm/1.0e+12;
//        double k3_m=k3_mm/1.0e+18;
//        double p1_m=p1_mm/1.0e+3;//xPixelSize_mm;
//        double p2_m=p2_mm/1.0e+3;//xPixelSize_mm;
//        double b1_m=0.0;//b1_pixel/xPixelSize_mm;
//        double b2_m=0.0;//b2_pixel/xPixelSize_mm;
        if(isDGAPSourceCalibration)
        {
            b1_mm=b1_pixel;//xPixelSize_mm;
            b2_mm=b2_pixel;//xPixelSize_mm;
//            b1_m=b1_mm;
//            b2_m=b2_mm;
        }
        if(!mLibSDGAP->setCameraParameters(cameraType,
                                           cameraId,
                                           cameraComment,
                                           focal_mm,
                                           xPPAFromCenter_mm,
                                           yPPAFromCenter_mm,
                                           columns,
                                           rows,
                                           xPixelSize_mc,
                                           yPixelSize_mc,
                                           strError))
        {
            return(false);
        }
        // Images file
        if(writeSDGAPInputFiles)
        {
            QString cameraFileName=sdgapInputFilesPath+"/"+LIBSDGAP_CAMERA_FILENAME;
            QFile cameraFile(cameraFileName);
            if(!cameraFile.open(QIODevice::WriteOnly | QIODevice::Text))
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error opening file:\n\t%1")
                        .arg(cameraFileName);
                return(false);
            }
            QTextStream cameraOut(&cameraFile);
            cameraOut<<"camera-ccd"<<"\n";
            cameraOut<<cameraId<<"  "<<cameraId<<"\n";
            cameraOut<<QString::number(focal_mm,'f',6)<<"  "
                     <<QString::number(xPPAFromCenter_mm,'f',6)<<"  "
                     <<QString::number(yPPAFromCenter_mm,'f',6)<<"\n";
            cameraOut<<QString::number(columns)<<"  "<<QString::number(rows)<<"\n";
            cameraOut<<QString::number(xPixelSize_mc,'f',3)<<"  "
                     <<QString::number(yPixelSize_mc,'f',3)<<"\n";
            cameraOut<<"stop-dep"<<"\n";
            cameraFile.close();

            QString imagesFileName=sdgapInputFilesPath+"/"+LIBSDGAP_IMAGES_FILENAME;
            QFile imagesFile(imagesFileName);
            if(!imagesFile.open(QIODevice::WriteOnly | QIODevice::Text))
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error opening file:\n\t%1")
                        .arg(imagesFileName);
                return(false);
            }
            QTextStream out(&imagesFile);
            for(int ni=0;ni<includedImages.size();ni++)
            {
                QString imageId=includedImages[ni];
                //QString stationId=LIBSDGAP_STATION_TAG+imageId;
                QString stationId=imageId;
                out<<"image-frame   "<<imageId<<"   "<<stationId<<"   "<<cameraId<<"\n";
            }
            out<<"stop-dep"<<"\n";
            imagesFile.close();
        }

        // Parámetros adicionales
        QString aditionalParameterModel,aditionalParameterId;
        QVector<double> initialValues,initialStds;
        double unknownFreeStd=1.0e+31;
        double unknownFixedStd=1.0e-31;
        if(dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS,Qt::CaseInsensitive)==0)
        {
            aditionalParameterModel=LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS;
            aditionalParameterId=LIBSDGAP_ADITIONAL_PARAMETERS_ID;
            initialValues.push_back(diff_xPPA_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(diff_yPPA_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(diff_focal_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k1_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k2_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k3_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(p1_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(p2_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(b1_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(b2_mm);
            initialStds.push_back(unknownFreeStd);
        }
        else if(dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_FIXED,Qt::CaseInsensitive)==0)
        {
            aditionalParameterModel=LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS;
            aditionalParameterId=LIBSDGAP_ADITIONAL_PARAMETERS_ID;
            initialValues.push_back(diff_xPPA_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(diff_yPPA_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(diff_focal_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k2_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k3_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(p1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(p2_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(b1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(b2_mm);
            initialStds.push_back(unknownFixedStd);
        }
        else if(dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_IRD,Qt::CaseInsensitive)==0)
        {
            aditionalParameterModel=LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS;
            aditionalParameterId=LIBSDGAP_ADITIONAL_PARAMETERS_ID;
            initialValues.push_back(diff_xPPA_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(diff_yPPA_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(diff_focal_m);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k1_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k2_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(k3_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(p1_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(p2_mm);
            initialStds.push_back(unknownFreeStd);
            initialValues.push_back(b1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(b2_mm);
            initialStds.push_back(unknownFixedStd);
        }
        else if(dgapId.compare(LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS_IRD_FIXED,Qt::CaseInsensitive)==0)
        {
            aditionalParameterModel=LIBSDGAP_ADITIONAL_PARAMETERS_ID_AUSTRALIS;
            aditionalParameterId=LIBSDGAP_ADITIONAL_PARAMETERS_ID;
            initialValues.push_back(diff_xPPA_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(diff_yPPA_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(diff_focal_m);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k2_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(k3_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(p1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(p2_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(b1_mm);
            initialStds.push_back(unknownFixedStd);
            initialValues.push_back(b2_mm);
            initialStds.push_back(unknownFixedStd);
        }
        if(!mLibSDGAP->setAditionalParams(sdgapInputFilesPath,
                                          aditionalParameterModel,
                                          aditionalParameterId,
                                          cameraId,
                                          initialValues,
                                          initialStds,
                                          strError))
        {
            return(false);
        }
    }

    MicMacEOReader exteriorReader;
    QFile* extoriFile=NULL;
    QTextStream* extoriOut=NULL;
    mSourceImageOrientationsXmlElements.clear();
    if(writeSDGAPInputFiles)
    {
        QString extoriFileName=sdgapInputFilesPath+"/"+LIBSDGAP_EXTORI_FILENAME;
        extoriFile=new QFile(extoriFileName);
        if(!extoriFile->open(QIODevice::WriteOnly | QIODevice::Text))
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error opening file:\n\t%1")
                    .arg(extoriFileName);
            return(false);
        }
        extoriOut=new QTextStream(extoriFile);
        (*extoriOut)<<"common-type"<<"\n"<<"\n";
        (*extoriOut)<<LIBSDGAP_LEASTSQUARES_EXTERIOR_ORIENTATION_OPK_FIX;
        (*extoriOut)<<"   "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_UNIT_OF_ROTATION_PARAMETERS<<"   0   1\n";
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"\n";
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
        (*extoriOut)<<"\n";
        (*extoriOut)<<"\n";
    }
    for(int nImageNode=0;nImageNode<imageNodes.size();nImageNode++)
    {
        QDomNode imageNode=imageNodes.at(nImageNode);
        if(!imageNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("Image node number %1 is not an element").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageElement=imageNode.toElement();
        QDomNodeList imageNameNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_NAME);
        if(imageNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a name node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageNameElement=imageNameNodes.at(0).toElement();
        QString imageName=imageNameElement.text().trimmed();
        QString imageId=imageName;
        if(!mImageNames.contains(imageName))
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, image name %2 is not valid").arg(QString::number(nImageNode+1)).arg(imageName);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageName];
        QDomNodeList shotNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_SHOT);
        if(shotNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a shot node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement shotElement=shotNodes.at(0).toElement();
        QDomNodeList orientationsNodes=shotElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        if(orientationsNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there are not one orientations node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement orientationsElement=orientationsNodes.at(0).toElement();
        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QDomElement orientationElement;
        QDomNode imageOrientationNode;
        bool findOrientation=false;
        for(int nC=0;nC<orientationNodes.size();nC++)
        {
            QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
            QString strName=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
            if(strName.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                strError+=QObject::tr("\nIn image node number %1, not found name attribute").arg(QString::number(nImageNode+1));
                return(false);
            }
            if(strName.compare(mSourceOrientation)==0)
            {
                QDomNode auxOrientationNode=orientationNodes.at(nC).cloneNode();
                orientationElement=auxOrientationNode.toElement();
                QDomNodeList auxNodes=orientationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                if(auxNodes.size()!=1)
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                    strError+=QObject::tr("\nIn image node number %1, not found tag %2")
                            .arg(QString::number(nImageNode+1)).arg(APERO_XMLFILES_TAG_EXPORT_APERO);
                    return(false);
                }
                imageOrientationNode=auxNodes.at(0);
                findOrientation=true;
                break;
            }
        }
        if(!findOrientation)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, not found orientation %2")
                    .arg(QString::number(nImageNode+1))
                    .arg(mSourceOrientation);
            return(false);
        }
        QDomElement imageOrientationElement=imageOrientationNode.toElement();
        ExteriorOrientation *extOri =  exteriorReader.read(imageOrientationElement);
        if (extOri == NULL)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error reading exterior orientation for image id:\n%1").arg(imageId);
            return(false);
        }
        mSourceImageOrientationsXmlElements[imageId]=orientationElement;
        QVector<double>* cp=extOri->getCP();
//        Camera *camera = mImages.at(nI)->getCamera();
        Camera *camera = mImagesByName[imageName]->getCamera();
        QString cameraId=camera->getName();
        QVector<QVector<double> >* rotationMatrix=extOri->getR();
//        mImages.at(nI)->setExteriorOrientation(extOri); // para luego actualizar y poder calcular precisiones
        mImagesByName[imageName]->setExteriorOrientation(extOri); // para luego actualizar y poder calcular precisiones
        if(!mLibSDGAP->setImageDefinition(LIBSDGAP_IMAGE_TYPE_FRAME_CAMERA,
                                          imageId,
                                          imageId,
                                          cameraId,
                                          strError))
        {
            return(false);
        }
        QString stationId=imageId;
        if(!mLibSDGAP->setImageExteriorOrientation(stationId,
                                                   LIBSDGAP_LEASTSQUARES_EXTERIOR_ORIENTATION_OPK_FIX,
                                                   cp,
                                                   rotationMatrix,
                                                   strError))
        {
            return(false);
        }
        if(writeSDGAPInputFiles)
        {
            (*extoriOut)<<"   "<<stationId;
            (*extoriOut)<<"   "<<QString::number(cp->at(0),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
            (*extoriOut)<<"   "<<QString::number(cp->at(1),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
            (*extoriOut)<<"   "<<QString::number(cp->at(2),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
            for(int nRow=0;nRow<3;nRow++)
            {
                for(int nColumn=0;nColumn<3;nColumn++)
                {
                    double sign=1.0;
                    if(nColumn>0)
                        sign=-1.0;
                    (*extoriOut)<<"   "<<QString::number((*rotationMatrix)[nRow][nColumn]*sign,'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_MATRIX_ROTATION_PRECISION);
                }
            }
            (*extoriOut)<<"\n";
        }
    }
    if(writeSDGAPInputFiles)
    {
        (*extoriOut)<<"\n";
        (*extoriOut)<<"stop-dep";
        extoriFile->close();
    }

    /*
    // Orientación externa
    {
        MicMacEOReader exteriorReader;
        QDomNodeList orientationsNodes=flightElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
        if(orientationsNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
            return(false);
        }
        if(orientationsNodes.size()>1)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
            return(false);
        }
        QDomNode orientationsNode=orientationsNodes.at(0);
        QDomElement orientationsElement=orientationsNode.toElement();

        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATION);
        QDomElement orientationElement;
        bool findOrientation=false;
        if(orientationNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere is not any %1 nodes in camera node").arg(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
            return(false);
        }
        else
        {
            for(int nC=0;nC<orientationNodes.size();nC++)
            {
                QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
                QString strId=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID).trimmed();
                if(strId.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nOrientation node number %1, not found id attribute").arg(QString::number(nC+1));
                    return(false);
                }
                if(strId.compare(calibrationId)==0)
                {
                    orientationElement=auxOrientationElement;
                    QDomNode clonedOrientationNode=orientationNodes.at(nC).cloneNode();
                    mImageOrientationXmlElement=clonedOrientationNode.toElement();
                    findOrientation=true;
                    break;
                }
            }
        }
        if(!findOrientation)
        {
            strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nOrientation %1 not found").arg(calibrationId);
            return(false);
        }
        QDomNodeList imageOrientationNodes=orientationElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QFile* extoriFile=NULL;
        QTextStream* extoriOut=NULL;
        if(writeSDGAPInputFiles)
        {
            QString extoriFileName=sdgapInputFilesPath+"/"+LIBSDGAP_EXTORI_FILENAME;
            extoriFile=new QFile(extoriFileName);
            if(!extoriFile->open(QIODevice::WriteOnly | QIODevice::Text))
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error opening file:\n\t%1")
                        .arg(extoriFileName);
                return(false);
            }
            extoriOut=new QTextStream(extoriFile);
            (*extoriOut)<<"common-type"<<"\n"<<"\n";
            (*extoriOut)<<LIBSDGAP_LEASTSQUARES_EXTERIOR_ORIENTATION_OPK_FIX;
            (*extoriOut)<<"   "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_UNIT_OF_ROTATION_PARAMETERS<<"   0   1\n";
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"\n";
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"      "<<LIBSDGAP_LEASTSQUARES_PARAMETERS_STANDARD_DESVIATION_FOR_UNKNOWN_NOT_ELIMINATED_STR;
            (*extoriOut)<<"\n";
            (*extoriOut)<<"\n";
        }
        for(int nI=0;nI<mImageNames.size();nI++)
        {
            QString imageId=mImageNames[nI];
            if(!includedImages.contains(imageId))
                continue;
            QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageId];
            QDomNode imageOrientationNode;
            bool findImageOrientation=false;
            for(int nIo=0;nIo<imageOrientationNodes.size();nIo++)
            {
                QDomElement auxImageOrientationElement=imageOrientationNodes.at(nIo).toElement();
                QString strId=auxImageOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
                if(strId.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nIn orientation id %1, image orientation node number %2, not found id attribute")
                            .arg(calibrationId)
                            .arg(QString::number(nIo+1));
                    return(false);
                }
                if(strId.compare(imageId)==0)
                {
                    QDomNodeList auxNodes=auxImageOrientationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                    imageOrientationNode=auxNodes.at(0);
                    findImageOrientation=true;
                    break;
                }
            }
            if(!findImageOrientation)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn orientation id %1, image orientation did %2 not found")
                        .arg(calibrationId)
                        .arg(imageId);
                return(false);
            }
            QDomElement imageOrientationElement=imageOrientationNode.toElement();
            ExteriorOrientation *extOri =  exteriorReader.read(imageOrientationElement);
            if (extOri == NULL)
            {
                strError=QObject::tr("OrientationProcessMonitor::getInputOrientationDataForSDGAP, error reading exterior orientation for image id:\n%1").arg(imageId);
                return(false);
            }
            QVector<double>* cp=extOri->getCP();
            Camera *camera = mImages.at(nI)->getCamera();
            QString cameraId=camera->getName();
            QVector<QVector<double> >* rotationMatrix=extOri->getR();
            mImages.at(nI)->setExteriorOrientation(extOri); // para luego actualizar y poder calcular precisiones
            if(!mLibSDGAP->setImageDefinition(LIBSDGAP_IMAGE_TYPE_FRAME_CAMERA,
                                              imageId,
                                              imageId,
                                              cameraId,
                                              strError))
            {
                return(false);
            }
            QString stationId=imageId;
            if(!mLibSDGAP->setImageExteriorOrientation(stationId,
                                                       LIBSDGAP_LEASTSQUARES_EXTERIOR_ORIENTATION_OPK_FIX,
                                                       cp,
                                                       rotationMatrix,
                                                       strError))
            {
                return(false);
            }
            if(writeSDGAPInputFiles)
            {
                (*extoriOut)<<"   "<<stationId;
                (*extoriOut)<<"   "<<QString::number(cp->at(0),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
                (*extoriOut)<<"   "<<QString::number(cp->at(1),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
                (*extoriOut)<<"   "<<QString::number(cp->at(2),'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_COORDINATES_PRECISION);
                for(int nRow=0;nRow<3;nRow++)
                {
                    for(int nColumn=0;nColumn<3;nColumn++)
                    {
                        double sign=1.0;
                        if(nColumn>0)
                            sign=-1.0;
                        (*extoriOut)<<"   "<<QString::number((*rotationMatrix)[nRow][nColumn]*sign,'f',LIBSDGAP_EXTORI_FILENAME_EXTORI_MATRIX_ROTATION_PRECISION);
                    }
                }
                (*extoriOut)<<"\n";
            }
        }
        if(writeSDGAPInputFiles)
        {
            (*extoriOut)<<"\n";
            (*extoriOut)<<"stop-dep";
            extoriFile->close();
        }
    }
    */
    return(true);
}

bool OrientationProcessMonitor::getMeasurementDataForSDGAP_m(bool matches_indiv_sdev,
                                                             float stdThreshold,
                                                             int numberOfTiePoints,
                                                             int gridSize,
                                                             QVector<QString> &includedImages,
                                                             bool writeSDGAPInputFiles,
                                                             QString &strError)
{
    if(!mLibSDGAP->initializeBundleAdjustmentFirstStep(strError))
    {
        return(false);
    }
    // Gestor de puntos de enlace
    if(!createTiePointsManager(strError,
                               gridSize))
    {
        return(false);
    }
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
        QFileInfo fileInfo(mXmlFileName);
        sdgapInputFilesPath=fileInfo.absolutePath();
    }
    if(!mLibSDGAP->setMatchesMeasurements_m(mTiePointsManager,
                                            matches_indiv_sdev,
                                            stdThreshold,
                                            numberOfTiePoints,
                                            includedImages,
                                            sdgapInputFilesPath,
                                            strError))
    {
        return(false);
    }

    return(true);
}

bool OrientationProcessMonitor::getMeasurementDataForSDGAP_t(bool matches_indiv_sdev,
                                                             QVector<QString> &includedImages,
                                                             bool writeSDGAPInputFiles,
                                                             QString &strError)
{
    if(!mLibSDGAP->initializeBundleAdjustmentFirstStep(strError))
    {
        return(false);
    }
    double stdThreshold=mStandardDesviationThreshold;
    int numberOfTiePoints=mNumberOfTiePointsInEachImage;
    int gridSize=mColumnsCcdGridSize;
    // Gestor de puntos de enlace
    if(!createTiePointsManager(strError,
                               gridSize))
    {
        return(false);
    }
    QString sdgapInputFilesPath;
    if(writeSDGAPInputFiles)
    {
//        QFileInfo fileInfo(mXmlFileName);
//        sdgapInputFilesPath=fileInfo.absolutePath();
        sdgapInputFilesPath=mTmpFolder;
    }
    if(!mLibSDGAP->setMatchesMeasurements_t(mTiePointsManager,
                                            matches_indiv_sdev,
                                            stdThreshold,
                                            numberOfTiePoints,
                                            includedImages,
                                            sdgapInputFilesPath,
                                            strError))
    {
        return(false);
    }

    return(true);
}

void OrientationProcessMonitor::onProcessFinished()
{
//    if(mIsTapioca)
//        onTapiocaProcessFinished();
//    else if(mIsAsift)
//        onASIFTProcessFinished();
//    else if(mIsOpenMVG)
//        onOpenMVGKpmFinished();
    QString msg=QObject::tr("Step   %1: Bundle adjustment process").arg(QString::number(mStep));
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();
    msg=QObject::tr("          ... Finished");
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();

    QString strError;
    QDomElement cameraXmlElement;
    QMap<QString,QDomElement> exteriorOrientationsXmlElements;
    if(!readOrientations(cameraXmlElement,
                         exteriorOrientationsXmlElements,
                         strError))
    {
        (*mStdOut) <<strError<< endl;
        QCoreApplication::exit();
    }

//    QMap<QString,PWImage*> imagesById; // ahora es mImagesByName
//    for(int nI=0;nI<mImages.size();nI++)
//    {
//        imagesById[mImages.at(nI)->getFileName()]=mImages.at(nI);
//    }

    if(mUpdateAccuracies)
    {
        msg=QObject::tr("Step   %1: Updating tie points accuracies").arg(QString::number(++mStep));
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();
        if(!PW::LibPW::updateTiePointsAccuracy(mImagesByName, //imagesById,
                                               mImagesFirstColumnsTiePoints,
                                               mImagesFirstRowsTiePoints,
                                               mImagesSecondColumnsTiePoints,
                                               mImagesSecondRowsTiePoints,
                                               mMatchesIds,
                                               mMatchesAccuracies,
                                               mAccuraciesByMatchId,
                                               strError))
        {
            (*mStdOut) <<strError<< endl;
            QCoreApplication::exit();
        }
        msg=QObject::tr("          ... Finished");
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();

        if(mOrientationIsFixed)
        {
            msg=QObject::tr("Step   %1: Updating GCPs accuracies").arg(QString::number(++mStep));
            (*mStdOut)<<msg<<"\n";
            (*mStdOut).flush();
    //        QMap<QString,QVector<float> > mGeometryGCPs; // (x,y,z,sx,sy,sz)
    //        QMap<QString,bool> mIsControlGCPs; // a falso será de chequeo
    //        QMap<QString,QMap<QString,QVector<float> > > mImageCoordinatesGCPs; // (x,y,std)
            // actualiza mGeometryGCPs pasando de (x,y,z,sx,sy,sz) a (x,y,z,sx,sy,sz,ex,ey,ez,e2d)
            // actualiza mImageCoordinatesGCPs de (x,y,std) a (x,y,std,ex,ey,e2d)
            if(!PW::LibPW::updateGCPPointsAccuracy(mImagesByName, //imagesById,imagesById,
                                                   mGeometryGCPs,
                                                   mImageCoordinatesGCPs,
                                                   strError))
            {
                (*mStdOut) <<strError<< endl;
                QCoreApplication::exit();
            }
            msg=QObject::tr("          ... Finished");
            (*mStdOut)<<msg<<"\n";
            (*mStdOut).flush();
        }
    }

    // Almacenamiento de resultados en el fichero XML del proyecto
    msg=QObject::tr("Step   %1: Storing camera calibration and/or orientations").arg(QString::number(++mStep));
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();
//    QString backupXmlProjectFileName=mXmlFileName+"_old";
//    if(!QFile::copy(mXmlFileName,backupXmlProjectFileName))
//    {
//        strError=QObject::tr("Error copying backup of xml project file");
//        (*mStdOut) <<strError<< endl;
//        QCoreApplication::exit();
//    }
    if(!writeSolutionToOrtoSkyXmlFile(cameraXmlElement,
                                      exteriorOrientationsXmlElements,
                                      strError))
    {
        (*mStdOut) <<strError<< endl;
//        if(!QFile::copy(backupXmlProjectFileName,mXmlFileName))
//        {
//            strError=QObject::tr("Error copying backup of xml project file");
//            (*mStdOut) <<strError<< endl;
//            QCoreApplication::exit();
//        }
//        QFile::remove(backupXmlProjectFileName);
        QCoreApplication::exit();
    }
    msg=QObject::tr("          ... Finished");
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();

//    QFile::remove(backupXmlProjectFileName);
    if(!removeRubbish(strError))
    {
        (*mStdOut) <<strError<< endl;
        QCoreApplication::exit();
    }
    QCoreApplication::exit();
}

void OrientationProcessMonitor::onProcessSDGAPPBAFinished(int& step,
                                                          bool printImageMaster)
{
    QString strError;
    QString msg=QObject::tr("Step   %1: SDGAP Bundle adjustment process").arg(QString::number(step));
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();
    msg=QObject::tr("          ... Finished");
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();

    QDomElement cameraXmlElement;
    QMap<QString,QDomElement> imageOrientationsXmlElements;
    if(!readOrientationsSDGAPFromOrtoSkyXml(cameraXmlElement,
                                            imageOrientationsXmlElements,
                                            strError))
    {
        (*mStdOut) <<strError<< endl;
        QCoreApplication::exit();
    }

//    QMap<QString,PWImage*> imagesById;
//    for(int nI=0;nI<mImages.size();nI++)
//    {
//        imagesById[mImages.at(nI)->getFileName()]=mImages.at(nI);
//    }

//    mUpdateAccuracies=false;
    if(mUpdateAccuracies)
    {
        msg=QObject::tr("Step   %1: Updating tie points accuracies").arg(QString::number(++step));
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();
        if(!updateTiePointsAccuracySDGAP(strError))
        {
            (*mStdOut) <<strError<< endl;
            QCoreApplication::exit();
        }
        msg=QObject::tr("          ... Finished");
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();

        if(mOrientationIsFixed)
        {
            msg=QObject::tr("Step   %1: Updating GCPs accuracies").arg(QString::number(++step));
            (*mStdOut)<<msg<<"\n";
            (*mStdOut).flush();
    //        QMap<QString,QVector<float> > mGeometryGCPs; // (x,y,z,sx,sy,sz)
    //        QMap<QString,bool> mIsControlGCPs; // a falso será de chequeo
    //        QMap<QString,QMap<QString,QVector<float> > > mImageCoordinatesGCPs; // (x,y,std)
            // actualiza mGeometryGCPs pasando de (x,y,z,sx,sy,sz) a (x,y,z,sx,sy,sz,ex,ey,ez,e2d)
            // actualiza mImageCoordinatesGCPs de (x,y,std) a (x,y,std,ex,ey,e2d)
            if(!updateGCPPointsAccuracySDGAP(strError))
            {
                (*mStdOut) <<strError<< endl;
                QCoreApplication::exit();
            }
            msg=QObject::tr("          ... Finished");
            (*mStdOut)<<msg<<"\n";
            (*mStdOut).flush();
        }
    }

    // Almacenamiento de resultados en el fichero XML del proyecto
    msg=QObject::tr("Step   %1: Storing camera calibration and/or orientations").arg(QString::number(++step));
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();
//    QString backupXmlProjectFileName=mXmlFileName+"_old";
//    if(QFile::exists(backupXmlProjectFileName))
//        QFile::remove(backupXmlProjectFileName);
//    if(!QFile::copy(mXmlFileName,backupXmlProjectFileName))
//    {
//        strError=QObject::tr("Error copying backup of xml project file");
//        (*mStdOut) <<strError<< endl;
//        //QCoreApplication::exit();
//    }
    if(!writeSDGAPSolutionToOrtoSkyXmlFile(cameraXmlElement,
                                           imageOrientationsXmlElements,
                                           strError))
    {
        (*mStdOut) <<strError<< endl;
//        if(!QFile::copy(backupXmlProjectFileName,mXmlFileName))
//        {
//            strError=QObject::tr("Error copying backup of xml project file");
//            (*mStdOut) <<strError<< endl;
//            QCoreApplication::exit();
//        }
//        QFile::remove(backupXmlProjectFileName);
        //QCoreApplication::exit();
    }
    msg=QObject::tr("          ... Finished");
    (*mStdOut)<<msg<<"\n";
    (*mStdOut).flush();

    if(printImageMaster)
    {
        msg=QObject::tr("Step   %1: Writing in ImageMaster format").arg(QString::number(++step));
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();
        if(!writeImageMasterImageCoordinates(cameraXmlElement,
                                             strError))
        {
            cerr <<strError.toStdString()<< endl;
            if(!removeRubbish(strError))
                return;
        }
        msg=QObject::tr("          ... Finished");
        (*mStdOut)<<msg<<"\n";
        (*mStdOut).flush();
    }
    /*
    QFile::remove(backupXmlProjectFileName);
    if(!removeRubbish(strError))
    {
        (*mStdOut) <<strError<< endl;
        QCoreApplication::exit();
    }
    */
    //QCoreApplication::exit();
}

bool OrientationProcessMonitor::processSDGAPPBA(QString &strError)
{
    mLibSDGAP->setPrintTiePointsAccuracies(mPrintTiePointsAccuracies);
    if(!mLibSDGAP->process(strError,mResultsFileName))
    {
        return(false);
    }
    return(true);
}

bool OrientationProcessMonitor::writeChantierBaseFile(QString micmacPath,
                                                      QString& strError)
{
    // *********** WRITE LeChantier... *******************//
    QString chantierBaseFileName=micmacPath+"/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME;
    if(!QFile::exists(chantierBaseFileName))
    {
        strError=QObject::tr("Apero initial camera file not found");
        return(false);
    }
    QFile chantierBaseFile(chantierBaseFileName);
    QFile chantierFile(mImagesPath + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME);
    if(QFile::exists(chantierFile.fileName()))
    {
        if(!chantierFile.remove())
        {
            strError=QObject::tr("Error removing file %1").arg(chantierFile.fileName());
            return(false);
        }
    }
    if(!chantierBaseFile.copy(mImagesPath + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME))
    {
        strError=QObject::tr("Error copying file %1 to %2").arg(chantierBaseFile.fileName()).arg(chantierFile.fileName());
        return(false);
    }
    QFile::setPermissions(mImagesPath + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME, QFile::ReadOwner | QFile::WriteOwner);
    replace(&chantierFile, &chantierFile,"PW_SENSOR_WIDTH", QString::number(mSensorWidth));
    replace(&chantierFile, &chantierFile,"PW_SENSOR_HEIGHT", QString::number(mSensorHeight));
    replace(&chantierFile, &chantierFile,"PW_FOCAL", QString::number(mFocal));
    return(true);
}

bool OrientationProcessMonitor::writeChantierBaseFileOrtoSkyXml(QString micmacPath,
                                                      QString& strError)
{
    // *********** WRITE LeChantier... *******************//
    QString chantierBaseFileName=micmacPath+"/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME;
    if(!QFile::exists(chantierBaseFileName))
    {
        strError=QObject::tr("Apero initial camera file not found");
        return(false);
    }
    QFile chantierBaseFile(chantierBaseFileName);
    QFile chantierFile(mTmpFolder + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME);
    if(QFile::exists(chantierFile.fileName()))
    {
        if(!chantierFile.remove())
        {
            strError=QObject::tr("Error removing file %1").arg(chantierFile.fileName());
            return(false);
        }
    }
    if(!chantierBaseFile.copy(mTmpFolder + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME))
    {
        strError=QObject::tr("Error copying file %1 to %2").arg(chantierBaseFile.fileName()).arg(chantierFile.fileName());
        return(false);
    }
    QFile::setPermissions(mTmpFolder + "/"+ORIENTATIONPROCESSMONITOR_MICMAC_CHANTIER_FILE_NAME, QFile::ReadOwner | QFile::WriteOwner);
    replace(&chantierFile, &chantierFile,"PW_SENSOR_WIDTH", QString::number(mSensorWidth));
    replace(&chantierFile, &chantierFile,"PW_SENSOR_HEIGHT", QString::number(mSensorHeight));
    replace(&chantierFile, &chantierFile,"PW_FOCAL", QString::number(mFocal));
    return(true);
}

bool OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile(QDomElement& calibrationElement,
                                                                   QMap<QString,QDomElement>& exteriorOrientationXmlElements,
                                                                   QString& strError)
{
    QString calibrationEngine=mPBAEngine;
    QString calibrationModel=mTapasDistModel;
    QString orientationId=mTargetOrientation;
    QString calibrationId=mTargetCalibration;
    QString orientationType;
    if(calibrationEngine.compare(PBA_COMPUTATIONS_ENGINE_APERO,Qt::CaseInsensitive)==0)
    {
        orientationType=ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_APERO;
    }
    else if(calibrationEngine.compare(PBA_COMPUTATIONS_ENGINE_SDGAP,Qt::CaseInsensitive)==0)
    {
        orientationType=ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_SDGAP;
    }
    if(orientationType.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile,\n");
        strError+=QObject::tr("Orientation type is not valid");
        return(false);
    }

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Grabación de la información de la calibración de la cámara
    QDomNodeList camerasNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCES);
    if(camerasNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node cameras");
        return(false);
    }
    QDomNode camerasNode=camerasNodes.at(0);
    QDomElement camerasElement=camerasNode.toElement();

    // Lectura de la información de la cámara
    QDomNodeList cameraNodes=camerasElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE);
    if(cameraNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag camera in the file");
        return(false);
    }
    QDomNode cameraNode;
    bool findCamera=false;
    for(int nCamera=0;nCamera<cameraNodes.size();nCamera++)
    {
        QDomNode auxCameraNode=cameraNodes.at(nCamera);
        QDomElement cameraElement=auxCameraNode.toElement();

        // Lectura del nombre de la cámara
        QDomNodeList cameraNameNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CAMERA_NAME);
        if(cameraNameNodes.size()!=1)
        {
            strError=QObject::tr("ExternalInterfaceProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading camera node number %1").arg(QString::number(nCamera+1));
            strError+=QObject::tr("\nCamera name node is not unique");
            return(false);
        }
        QDomNode cameraNameNode=cameraNameNodes.at(0);
        QString cameraName=cameraNameNode.toElement().text().trimmed();
        if(cameraName.compare(mCameraName,Qt::CaseInsensitive)==0)
        {
            findCamera=true;
            cameraNode=auxCameraNode;
        }
    }
    if(!findCamera)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo camera %1 in the file").arg(mCameraName);
        return(false);
    }
    QDomElement cameraElement=cameraNode.toElement();

    QDomNodeList calibrationsNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
    QDomElement calibrationsElement;
    if(calibrationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one calibrations nodes in camera node");
        return(false);
    }
    else if(calibrationsNodes.size()==1)
    {
        calibrationsElement=calibrationsNodes.at(0).toElement();
        cameraElement.removeChild(calibrationsElement);
    }
    else if(calibrationsNodes.size()==0)
    {
        calibrationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
    }
    QDomNodeList calibrationNodes=calibrationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
    QDomElement calibrationElementToReplace;
    int posEqualCalibration=-1;
    if(calibrationNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are not calibration nodes");
    }
    else
    {
        for(int nC=0;nC<calibrationNodes.size();nC++)
        {
            QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
            QString strId=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME).trimmed();
            if(strId.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nCalibration node number %1, not found id attribute").arg(QString::number(nC+1));
                return(false);
            }
            if(strId.compare(calibrationId)==0)
            {
                calibrationElementToReplace=auxCalibrationElement;
                posEqualCalibration=nC;
                break;
            }
        }
    }
    QString type=mPBACalibrationModel->getOrtoSkyType();
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_TYPE,type);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME,calibrationId);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,calibrationEngine);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,calibrationModel);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_SOURCE_CALIBRATION_ID,mSourceCalibration);
//    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_APERO_FILENAME,mCalibrationFileName);

//    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID,calibrationId);
//    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,calibrationEngine);
//    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,calibrationModel);
//    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_SOURCE_CALIBRATION_ID,mSourceOrientation);
//    //calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_APERO_FILENAME,mCalibrationFileName);
    if(posEqualCalibration>-1)
    {
        calibrationsElement.replaceChild(calibrationElement,calibrationElementToReplace);
    }
    else
        calibrationsElement.appendChild(calibrationElement);
    cameraElement.appendChild(calibrationsElement);

//    QDomNodeList projectNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PROJECT);
//    if(projectNodes.size()==0)
//    {
//        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
//        strError+=QObject::tr("\nNo tag project in the file");
//        return(false);
//    }
//    if(projectNodes.size()>1)
//    {
//        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
//        strError+=QObject::tr("\nThere are more than one project node");
//        return(false);
//    }
//    QDomElement projectElement=projectNodes.at(0).toElement();
//    QDomNodeList orientationsNodes=projectElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);


    // Almacenamiento de las orientaciones en las imágenes
    QDomNodeList imagesNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGES);
    if(imagesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag images in the session name %1").arg(mSessionName);
        return(false);
    }
    if(imagesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one images node in session name %1").arg(mSessionName);
        return(false);
    }
    QDomNode imagesNode=imagesNodes.at(0);
    QDomElement imagesElement=imagesNode.toElement();
    QDomNodeList imageNodes=imagesElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE);
    if(imageNodes.size()<2)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
        strError+=QObject::tr("\nIn node images must be more than one image nodes");
        return(false);
    }
    double pi=4.0*atan(1.0);
    for(int nImageNode=0;nImageNode<imageNodes.size();nImageNode++)
    {
        QDomNode imageNode=imageNodes.at(nImageNode);
        if(!imageNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("Image node number %1 is not an element").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageElement=imageNode.toElement();
        QDomNodeList imageNameNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_NAME);
        if(imageNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a name node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageNameElement=imageNameNodes.at(0).toElement();
        QString imageName=imageNameElement.text().trimmed();
        if(!mImageNames.contains(imageName))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, image name %2 is not valid").arg(QString::number(nImageNode+1)).arg(imageName);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageName];
        QDomNodeList shotNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_SHOT);
        if(shotNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a shot node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement shotElement=shotNodes.at(0).toElement();
        QDomNodeList orientationsNodes=shotElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        QDomElement orientationsElement;
        if(orientationsNodes.size()==0)
        {
            orientationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        }
        else if(orientationsNodes.size()==1)
        {
            orientationsElement=orientationsNodes.at(0).toElement();
        }
        else
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there are more that one orientations node").arg(QString::number(nImageNode+1));
            return(false);
        }
        orientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS_ATTRIBUTE_CURRENT,orientationId);
        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QDomElement orientationElement;
        QDomElement orientationElementToReplace;
        int posEqualOrientation=-1;
        if(orientationNodes.size()==0)
        {
            orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        }
        else
        {
            for(int nC=0;nC<orientationNodes.size();nC++)
            {
                QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
                QString strName=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
                if(strName.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                    strError+=QObject::tr("\nIn image node number %1, not found name attribute").arg(QString::number(nImageNode+1));
                    return(false);
                }
                if(strName.compare(orientationId)==0)
                {
                    orientationElementToReplace=auxOrientationElement;
                    posEqualOrientation=nC;
                    break;
                }
            }
            orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        }
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME,orientationId);
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_TYPE,orientationType);
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_CALIBRATION,calibrationId);
        if(mOrientationIsFixed)
            orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_GROUND_CONTROL,
                                            "yes");
        else
            orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_GROUND_CONTROL,
                                            "no");
        QDomElement auxOrientationElement=exteriorOrientationXmlElements[imageFileNameWithoutPath];
        QDomNodeList auxNodes=auxOrientationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        if(auxNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSDGAPSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn image %1 in orientation %2 not found tag %3")
                    .arg(imageName).arg(orientationId).arg(APERO_XMLFILES_TAG_EXPORT_APERO);
            return(false);
        }
        QDomElement auxOrientationElementExport=auxNodes.at(0).toElement();
//        orientationElement.appendChild(exteriorOrientationXmlElements[imageFileNameWithoutPath]);
        QDomNode crsNode=mCrsNode.cloneNode();
        orientationElement.appendChild(crsNode.toElement());
        // Recuperación de la posición y attitude
        PW::PWImage* image=mImagesByName[imageName];
        QVector< QVector<double> > * r = image->getExteriorOrientation()->getR();
        double r11=(*r)[0][0];
        double r12=-1.0*(*r)[0][1];
        double r13=-1.0*(*r)[0][2];
        double r21=(*r)[1][0];
        double r22=-1.0*(*r)[1][1];
        double r23=-1.0*(*r)[1][2];
        double r31=(*r)[2][0];
        double r32=-1.0*(*r)[2][1];
        double r33=-1.0*(*r)[2][2];
//        (*r)[0][1]=-1.0(*r)[0][1];
//        r->[0][2]=-1.0*r->[0][2];
//        r->[1][1]=-1.0*r->[1][1];
//        r->[1][2]=-1.0*r->[1][2];
//        r->[2][1]=-1.0*r->[2][1];
//        r->[2][2]=-1.0*r->[2][2];
//        omega = (T)atan2(-A32, A33); // rotmatrix3.h
//        phi = (T)asin(A31);
//        kappa = (T)atan2(-A21, A11);
        double omega=atan2(-1.0*r32,r33);
        double phi=asin(r31);
        double kappa=atan2(-1.0*r21,r11);;
        QVector<double> * cp1 = image->getExteriorOrientation()->getCP();
        QString strX=QString::number(cp1->at(0),'f',9);
        QString strY=QString::number(cp1->at(1),'f',9);
        QString strZ=QString::number(cp1->at(2),'f',9);
        QString strOmega=QString::number(omega*180.0/pi,'f',12);
        QString strPhi=QString::number(phi*180.0/pi,'f',12);
        QString strKappa=QString::number(kappa*180.0/pi,'f',12);
        QDomElement positionElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_TAG);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_X,strX);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_Y,strY);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_Z,strZ);
        orientationElement.appendChild(positionElement);
        QDomElement attitudeElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_TAG);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_OMEGA,strOmega);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_PHI,strPhi);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_KAPPA,strKappa);
        orientationElement.appendChild(attitudeElement);
//        orientationElement.appendChild(exteriorOrientationXmlElements[imageFileNameWithoutPath]);
        orientationElement.appendChild(auxOrientationElementExport);
        if(posEqualOrientation>-1)
        {
            orientationsElement.replaceChild(orientationElement,orientationElementToReplace);
        }
        else
            orientationsElement.appendChild(orientationElement);
        shotElement.appendChild(orientationsElement);
    }

/*
    QDomNodeList orientationsNodes=flightElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
    QDomElement orientationsElement;
    if(orientationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one orientations nodes in flight element node");
        return(false);
    }
    else if(orientationsNodes.size()==1)
    {
        orientationsElement=orientationsNodes.at(0).toElement();
        flightElement.removeChild(orientationsElement);
    }
    else if(orientationsNodes.size()==0)
    {
        orientationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
    }
    orientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATIONS_ATTRIBUTE_CURRENT,calibrationId);
    QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATION);
    QDomElement orientationElementToReplace;
    int posEqualOrientation=-1;
    if(orientationNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are not orientations nodes");
        return(false);
    }
    else
    {
        for(int nC=0;nC<orientationNodes.size();nC++)
        {
            QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
            QString strId=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID).trimmed();
            if(strId.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nOrientation node number %1, not found id attribute").arg(QString::number(nC+1));
                return(false);
            }
            if(strId.compare(calibrationId)==0)
            {
                orientationElementToReplace=auxOrientationElement;
                posEqualOrientation=nC;
                break;
            }
        }
    }
    orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID,calibrationId);
    if(mOrientationIsFixed)
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_TYPE,
                                        ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_FIXED);
    else
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_TYPE,
                                        ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_FREE);
    if(posEqualOrientation>-1)
    {
        orientationsElement.replaceChild(orientationElement,orientationElementToReplace);
    }
    else
        orientationsElement.appendChild(orientationElement);
    flightElement.appendChild(orientationsElement);

//    // Actualización de las precisiones
//    QDomNodeList pairsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
//    QDomNode pairsNode=pairsNodes.at(0);
//    QDomElement pairsElement=pairsNode.toElement();
//    QDomNodeList pairNodes=pairsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR);
//    for(int nPairNode=0;nPairNode<pairNodes.size();nPairNode++)
//    {
//        QDomNode pairNode=pairNodes.at(nPairNode);
//        QDomElement pairElement=pairNode.toElement();

//        QDomNodeList photo1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO1);
//        QDomElement photo1Element=photo1DataNodes.at(0).toElement();
//        QString strPhoto1=photo1Element.text();
//        bool toInt=false;
//        int photo1=strPhoto1.toInt(&toInt);

//        QDomNodeList photo2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO2);
//        QDomElement photo2Element=photo2DataNodes.at(0).toElement();
//        QString strPhoto2=photo2Element.text();
//        toInt=false;
//        int photo2=strPhoto2.toInt(&toInt);

//        QString image1FileName=mImagesFileNameByPos[photo1];
//        QString image2FileName=mImagesFileNameByPos[photo2];

//        QDomNodeList pointsDataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINTS);
//        if(pointsDataNodes.size()==0) // De esta forma no figuran pares sin puntos
//            continue;

//        QDomElement pointsElement=pointsDataNodes.at(0).toElement();
//        QDomNodeList pntsDataNodes=pointsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINT);
//        if(pntsDataNodes.size()<3)
//        {
//            continue;
////            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(fileName);
////            strError+=QObject::tr("\nIn pair node number %1, the number of matches is less than tree").arg(QString::number(nPairNode+1));
////            return(false);
//        }

//        QVector<float> accuracies;
//        bool findAccuracies=false;
//        if(mMatchesAccuracies.contains(image1FileName))
//        {
//            if(mMatchesAccuracies[image1FileName].contains(image2FileName))
//            {
//                findAccuracies=true;
//                accuracies=mMatchesAccuracies[image1FileName][image2FileName];
//            }
//        }
////        if(!findAccuracies)
////        {
////            if(matchesAccuracies.contains(image2FileName))
////            {
////                if(matchesAccuracies[image2FileName].contains(image1FileName))
////                {
////                    findAccuracies=true;
////                    accuracies=matchesAccuracies[image2FileName][image1FileName];
////                }
////            }
////        }
//        if(!findAccuracies)
//        {
//            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//            strError+=QObject::tr("\nNot found matches accuracies for pair: %1 - %2").arg(image1FileName).arg(image2FileName);
//            return(false);
//        }
//        for(int nPnt=0;nPnt<pntsDataNodes.size();nPnt++)
//        {
//            pntsDataNodes.at(nPnt).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_ACCURACY,
//                                                            QString::number(accuracies[nPnt],'f',mImageCoordinatesPrecision));
//        }
//    }

//    // Actualización de las precisiones de los puntos de apoyo
//    if(mOrientationIsFixed)
//    {
//        QDomNodeList gcpsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
//        QDomNode gcpsNode=gcpsNodes.at(0);
//        QDomElement gcpsElement=gcpsNode.toElement();
//        QDomNodeList gcpNodes=gcpsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCP);
//        for(int nGcpNode=0;nGcpNode<gcpNodes.size();nGcpNode++)
//        {
//            QDomNode gcpNode=gcpNodes.at(nGcpNode);
//            QDomElement gcpElement=gcpNode.toElement();
//            QDomNodeList photoDataNodes=gcpElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_GCP_TAG_IMG);
//            if(photoDataNodes.size()==0) // puntos que todavía no han sido medidos
//                continue;

//            QString gcpName=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_NAME);
//            if(!mGeometryGCPs.contains(gcpName))
//            {
//                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                strError+=QObject::tr("\nNot found GCP name: %1 in GCPs container ").arg(gcpName);
//                return(false);
//            }
//            if(!mImageCoordinatesGCPs.contains(gcpName))
//            {
//                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                strError+=QObject::tr("\nNot found GCP name: %1 in image coordinates GCPs container ").arg(gcpName);
//                return(false);
//            }

//            float eX=mGeometryGCPs[gcpName][6];
//            float eY=mGeometryGCPs[gcpName][7];
//            float eZ=mGeometryGCPs[gcpName][8];
//            float e2d=mGeometryGCPs[gcpName][9];
//            float e3d=sqrt(eX*eX+eY*eY+eZ*eZ);
//            gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EX_COORDINATE,
//                                                           QString::number(eX,'f',ORTOSKYXMLMATCHESFILE_GCP_PRECISION));
//            gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EY_COORDINATE,
//                                                           QString::number(eY,'f',ORTOSKYXMLMATCHESFILE_GCP_PRECISION));
//            gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EZ_COORDINATE,
//                                                           QString::number(eZ,'f',ORTOSKYXMLMATCHESFILE_GCP_PRECISION));
//            gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_E2D_COORDINATE,
//                                                           QString::number(e2d,'f',ORTOSKYXMLMATCHESFILE_GCP_PRECISION));
//            gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_E3D_COORDINATE,
//                                                           QString::number(e3d,'f',ORTOSKYXMLMATCHESFILE_GCP_PRECISION));

//            for(int nPhoto=0;nPhoto<photoDataNodes.size();nPhoto++)
//            {
//                QDomElement photoElement=photoDataNodes.at(nPhoto).toElement();
//                QString imagePos=photoElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_ID);
//                bool toInt=false;
//                int photo=imagePos.toInt(&toInt);
//                if(!toInt)
//                {
//                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                    strError+=QObject::tr("\nFor GCP name: %1 error in image number: %2")
//                            .arg(gcpName)
//                            .arg(imagePos);
//                    return(false);
//                }
//                QString imageId=mImagesFileNameByPos[photo];
//                if(!mImageCoordinatesGCPs[gcpName].contains(imageId))
//                {
//                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                    strError+=QObject::tr("\nFor GCP name: %1 not exists coordinates in image: %2")
//                            .arg(gcpName)
//                            .arg(imageId);
//                    return(false);
//                }
//                float exi=mImageCoordinatesGCPs[gcpName][imageId][3];
//                float eyi=mImageCoordinatesGCPs[gcpName][imageId][4];
//                float e2d=mImageCoordinatesGCPs[gcpName][imageId][5];
//                photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_EX_COORDINATE,
//                                                                   QString::number(exi,'f',mImageCoordinatesPrecision+1));
//                photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_EY_COORDINATE,
//                                                                   QString::number(eyi,'f',mImageCoordinatesPrecision+1));
//                photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_E2D_COORDINATE,
//                                                                   QString::number(e2d,'f',mImageCoordinatesPrecision+1));
//            }
//        }
//    }
*/
    const int IndentSize = 4;
    QFile file(mXmlFileName);
    //QFile file("kakita.xml");
    if (!file.open(QFile::WriteOnly | QFile::Text))
    {
        strError=tr("Error opening xml file:\n%1").arg(mXmlFileName);
        return(false);
    }
    QTextStream out(&file);
    mDoc.save(out, IndentSize);
    return(true);
}

bool OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile(QDomElement& cameraModelXmlElement,
                                                              QMap<QString,QDomElement>& exteriorOrientationXmlElements,
                                                              QString& strError)
{
    QString calibrationEngine=mPBAEngine;
    QString calibrationModel=mTapasDistModel;
    QString calibrationId=mTargetCalibration;
    QString orientationId=mTargetOrientation;
    QString orientationType;
    if(calibrationEngine.compare(PBA_COMPUTATIONS_ENGINE_APERO,Qt::CaseInsensitive)==0)
    {
        orientationType=ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_APERO;
    }
    else if(calibrationEngine.compare(PBA_COMPUTATIONS_ENGINE_SDGAP,Qt::CaseInsensitive)==0)
    {
        orientationType=ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_SDGAP;
    }
    if(orientationType.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile,\n");
        strError+=QObject::tr("Orientation type is not valid");
        return(false);
    }
    for(int nImageId=0;nImageId<mImageNames.size();nImageId++)
    {
        QString imageId=mImageNames[nImageId];
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageId];
        if(!exteriorOrientationXmlElements.contains(imageFileNameWithoutPath))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile,\n");
            strError+=QObject::tr("No image %1 in exterior orientations container").arg(imageId);
            return(false);
        }
    }
//    QMap<int,QString>::const_iterator iter=mImagesFileNameByPos.begin();
//    while(iter!=mImagesFileNameByPos.end())
//    {
//        QString imageId=iter.value();
//        if(!exteriorOrientationXmlElements.contains(imageId))
//        {
//            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile,\n");
//            strError+=QObject::tr("No image %1 in exterior orientations container").arg(imageId);
//            return(false);
//        }
//        iter++;
//    }

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Almacenamiento de los resultados de la calibracion
    QString calibration=mSourceCalibration;
    if(!mCalibrationIsFixed)
    {
        calibration=mTargetCalibration;
        QDomNodeList camerasNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCES);
        if(camerasNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nShould be only one node sources");
            return(false);
        }
        QDomNode camerasNode=camerasNodes.at(0);
        QDomElement camerasElement=camerasNode.toElement();

        // Lectura de la información de la cámara
        QDomNodeList cameraNodes=camerasElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE);
        if(cameraNodes.size()==0)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo tag source in the file");
            return(false);
        }
        QDomNode cameraNode;
        bool findCamera=false;
        for(int nCamera=0;nCamera<cameraNodes.size();nCamera++)
        {
            QDomNode auxCameraNode=cameraNodes.at(nCamera);
            QDomElement cameraElement=auxCameraNode.toElement();

            // Lectura del nombre de la cámara
            QDomNodeList cameraNameNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CAMERA_NAME);
            if(cameraNameNodes.size()!=1)
            {
                strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading source node number %1").arg(QString::number(nCamera+1));
                strError+=QObject::tr("\nSource name node is not unique");
                return(false);
            }
            QDomNode cameraNameNode=cameraNameNodes.at(0);
            QString cameraName=cameraNameNode.toElement().text().trimmed();
            if(cameraName.compare(mCameraName,Qt::CaseInsensitive)==0)
            {
                findCamera=true;
                cameraNode=auxCameraNode;
            }
        }
        if(!findCamera)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nNo source %1 in the file").arg(mCameraName);
            return(false);
        }
        QDomElement cameraElement=cameraNode.toElement();

        QDomNodeList calibrationsNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
        QDomElement calibrationsElement;
        if(calibrationsNodes.size()>1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nThere are more than one calibrations nodes in camera node");
            return(false);
        }
        else if(calibrationsNodes.size()==1)
        {
            calibrationsElement=calibrationsNodes.at(0).toElement();
            cameraElement.removeChild(calibrationsElement);
        }
        else if(calibrationsNodes.size()==0)
        {
            calibrationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
        }
        QDomNodeList calibrationNodes=calibrationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
        QDomElement calibrationElement;
        QDomElement calibrationElementToReplace;
        int posEqualCalibration=-1;
        if(calibrationNodes.size()==0)
        {
            calibrationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
        }
        else
        {
            for(int nC=0;nC<calibrationNodes.size();nC++)
            {
                QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
                QString strName=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME).trimmed();
                if(strName.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nCalibration node number %1, not found name attribute").arg(QString::number(nC+1));
                    return(false);
                }
                if(strName.compare(calibrationId)==0)
                {
                    calibrationElementToReplace=auxCalibrationElement;
                    posEqualCalibration=nC;
                    break;
                }
            }
            calibrationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
        }
        QString type=mPBACalibrationModel->getOrtoSkyType();
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_TYPE,type);
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME,calibrationId);
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,calibrationEngine);
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,calibrationModel);
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_SOURCE_CALIBRATION_ID,mSourceCalibration);
        calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_APERO_FILENAME,mCalibrationFileName);
        calibrationElement.appendChild(cameraModelXmlElement);
        if(posEqualCalibration>-1)
        {
            calibrationsElement.replaceChild(calibrationElement,calibrationElementToReplace);
        }
        else
            calibrationsElement.appendChild(calibrationElement);
        cameraElement.appendChild(calibrationsElement);
    }

    // Almacenamiento de las orientaciones en las imágenes
    QDomNodeList imagesNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGES);
    if(imagesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag images in the session name %1").arg(mSessionName);
        return(false);
    }
    if(imagesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one images node in session name %1").arg(mSessionName);
        return(false);
    }
    QDomNode imagesNode=imagesNodes.at(0);
    QDomElement imagesElement=imagesNode.toElement();
    QDomNodeList imageNodes=imagesElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE);
    if(imageNodes.size()<2)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
        strError+=QObject::tr("\nIn node images must be more than one image nodes");
        return(false);
    }
    double pi=4.0*atan(1.0);
    for(int nImageNode=0;nImageNode<imageNodes.size();nImageNode++)
    {
        QDomNode imageNode=imageNodes.at(nImageNode);
        if(!imageNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("Image node number %1 is not an element").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageElement=imageNode.toElement();
        QDomNodeList imageNameNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_NAME);
        if(imageNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a name node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageNameElement=imageNameNodes.at(0).toElement();
        QString imageName=imageNameElement.text().trimmed();
        if(!mImageNames.contains(imageName))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, image name %2 is not valid").arg(QString::number(nImageNode+1)).arg(imageName);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageName];
        QDomNodeList shotNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_SHOT);
        if(shotNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a shot node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement shotElement=shotNodes.at(0).toElement();
        QDomNodeList orientationsNodes=shotElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        QDomElement orientationsElement;
        if(orientationsNodes.size()==0)
        {
            orientationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        }
        else if(orientationsNodes.size()==1)
        {
            orientationsElement=orientationsNodes.at(0).toElement();
        }
        else
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there are more that one orientations node").arg(QString::number(nImageNode+1));
            return(false);
        }
        orientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS_ATTRIBUTE_CURRENT,orientationId);
        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QDomElement orientationElement;
        QDomElement orientationElementToReplace;
        int posEqualOrientation=-1;
        if(orientationNodes.size()==0)
        {
            orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        }
        else
        {
            for(int nC=0;nC<orientationNodes.size();nC++)
            {
                QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
                QString strName=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
                if(strName.isEmpty())
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                    strError+=QObject::tr("\nIn image node number %1, not found name attribute").arg(QString::number(nImageNode+1));
                    return(false);
                }
                if(strName.compare(orientationId)==0)
                {
                    orientationElementToReplace=auxOrientationElement;
                    posEqualOrientation=nC;
                    break;
                }
            }
            orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        }
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME,orientationId);
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_TYPE,orientationType);
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_CALIBRATION,calibration);
        if(mOrientationIsFixed)
            orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_GROUND_CONTROL,
                                            "yes");
        else
            orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_GROUND_CONTROL,
                                            "no");
        QDomNode crsNode=mCrsNode.cloneNode();
        orientationElement.appendChild(crsNode.toElement());
        // Recuperación de la posición y attitude
        PW::PWImage* image=mImagesByName[imageName];
        QVector< QVector<double> > * r = image->getExteriorOrientation()->getR();
        double r11=(*r)[0][0];
        double r12=-1.0*(*r)[0][1];
        double r13=-1.0*(*r)[0][2];
        double r21=(*r)[1][0];
        double r22=-1.0*(*r)[1][1];
        double r23=-1.0*(*r)[1][2];
        double r31=(*r)[2][0];
        double r32=-1.0*(*r)[2][1];
        double r33=-1.0*(*r)[2][2];
//        (*r)[0][1]=-1.0(*r)[0][1];
//        r->[0][2]=-1.0*r->[0][2];
//        r->[1][1]=-1.0*r->[1][1];
//        r->[1][2]=-1.0*r->[1][2];
//        r->[2][1]=-1.0*r->[2][1];
//        r->[2][2]=-1.0*r->[2][2];
//        omega = (T)atan2(-A32, A33); // rotmatrix3.h
//        phi = (T)asin(A31);
//        kappa = (T)atan2(-A21, A11);
        double omega=atan2(-1.0*r32,r33);
        double phi=asin(r31);
        double kappa=atan2(-1.0*r21,r11);;
        QVector<double> * cp1 = image->getExteriorOrientation()->getCP();
        QString strX=QString::number(cp1->at(0),'f',9);
        QString strY=QString::number(cp1->at(1),'f',9);
        QString strZ=QString::number(cp1->at(2),'f',9);
        QString strOmega=QString::number(omega*180.0/pi,'f',12);
        QString strPhi=QString::number(phi*180.0/pi,'f',12);
        QString strKappa=QString::number(kappa*180.0/pi,'f',12);
        QDomElement positionElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_TAG);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_X,strX);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_Y,strY);
        positionElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_POSITION_ATTRIBUTE_Z,strZ);
        orientationElement.appendChild(positionElement);
        QDomElement attitudeElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_TAG);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_OMEGA,strOmega);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_PHI,strPhi);
        attitudeElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTITUDE_ATTRIBUTE_KAPPA,strKappa);
        orientationElement.appendChild(attitudeElement);
        orientationElement.appendChild(exteriorOrientationXmlElements[imageFileNameWithoutPath]);
        if(posEqualOrientation>-1)
        {
            orientationsElement.replaceChild(orientationElement,orientationElementToReplace);
        }
        else
            orientationsElement.appendChild(orientationElement);
        shotElement.appendChild(orientationsElement);
    }

    if(mUpdateAccuracies)
    {
        // Actualización de las precisiones
//        QDomNodeList pairsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
        QDomNodeList pairsNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
        QDomNode pairsNode=pairsNodes.at(0);
        QDomElement pairsElement=pairsNode.toElement();
        QDomNodeList pairNodes=pairsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR);
        for(int nPairNode=0;nPairNode<pairNodes.size();nPairNode++)
        {
            QDomNode pairNode=pairNodes.at(nPairNode);
            QDomElement pairElement=pairNode.toElement();

//            QDomNodeList photo1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO1);
//            QDomElement photo1Element=photo1DataNodes.at(0).toElement();
//            QString strPhoto1=photo1Element.text();
//            bool toInt=false;
//            int photo1=strPhoto1.toInt(&toInt);

//            QDomNodeList photo2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO2);
//            QDomElement photo2Element=photo2DataNodes.at(0).toElement();
//            QString strPhoto2=photo2Element.text();
//            toInt=false;
//            int photo2=strPhoto2.toInt(&toInt);

//            QString image1FileName=mImagesFileNameByPos[photo1];
//            QString image2FileName=mImagesFileNameByPos[photo2];

            QDomNodeList image1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_IMAGE1);
            QDomElement image1Element=image1DataNodes.at(0).toElement();
            QString image1Name=image1Element.text().trimmed();

            QDomNodeList image2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_IMAGE2);
            QDomElement image2Element=image2DataNodes.at(0).toElement();
            QString image2Name=image2Element.text().trimmed();

//            QString image1FileName=mImageFileNamesByName[image1Name];
//            QString image2FileName=mImageFileNamesByName[image2Name];

            QDomNodeList pointsDataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINTS);
            if(pointsDataNodes.size()==0) // De esta forma no figuran pares sin puntos
                continue;

            QDomElement pointsElement=pointsDataNodes.at(0).toElement();
            QDomNodeList pntsDataNodes=pointsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINT);
            if(pntsDataNodes.size()<3)
            {
                continue;
    //            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(fileName);
    //            strError+=QObject::tr("\nIn pair node number %1, the number of matches is less than tree").arg(QString::number(nPairNode+1));
    //            return(false);
            }

            QVector<float> accuracies;
            bool findAccuracies=false;
//            if(mMatchesAccuracies.contains(image1FileName))
//            {
//                if(mMatchesAccuracies[image1FileName].contains(image2FileName))
//                {
//                    findAccuracies=true;
//                    accuracies=mMatchesAccuracies[image1FileName][image2FileName];
//                }
//            }
            if(mMatchesAccuracies.contains(image1Name))
            {
                if(mMatchesAccuracies[image1Name].contains(image2Name))
                {
                    findAccuracies=true;
                    accuracies=mMatchesAccuracies[image1Name][image2Name];
                }
            }
    //        if(!findAccuracies)
    //        {
    //            if(matchesAccuracies.contains(image2FileName))
    //            {
    //                if(matchesAccuracies[image2FileName].contains(image1FileName))
    //                {
    //                    findAccuracies=true;
    //                    accuracies=matchesAccuracies[image2FileName][image1FileName];
    //                }
    //            }
    //        }
            if(!findAccuracies)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                strError+=QObject::tr("\nNot found matches accuracies for pair: %1 - %2").arg(image1FileName).arg(image2FileName);
                strError+=QObject::tr("\nNot found matches accuracies for pair: %1 - %2").arg(image1Name).arg(image2Name);
                return(false);
            }
            for(int nPnt=0;nPnt<pntsDataNodes.size();nPnt++)
            {
                pntsDataNodes.at(nPnt).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_ACCURACY,
                                                                QString::number(accuracies[nPnt],'f',mImageCoordinatesPrecision));
            }
        }

        // Actualización de las precisiones de los puntos de apoyo
        if(mOrientationIsFixed)
        {
//            QDomNodeList gcpsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
            QDomNodeList gcpsNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCPS);
            QDomNode gcpsNode=gcpsNodes.at(0);
            QDomElement gcpsElement=gcpsNode.toElement();
            QDomNodeList gcpNodes=gcpsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_GCP);
            for(int nGcpNode=0;nGcpNode<gcpNodes.size();nGcpNode++)
            {
                QDomNode gcpNode=gcpNodes.at(nGcpNode);
                QDomElement gcpElement=gcpNode.toElement();
                QDomNodeList photoDataNodes=gcpElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_GCP_TAG_IMG);
                if(photoDataNodes.size()==0) // puntos que todavía no han sido medidos
                    continue;

                QString gcpName=gcpElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_NAME);
                if(!mGeometryGCPs.contains(gcpName))
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
                    strError+=QObject::tr("\nNot found GCP name: %1 in GCPs container ").arg(gcpName);
                    return(false);
                }
                if(!mImageCoordinatesGCPs.contains(gcpName))
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
                    strError+=QObject::tr("\nNot found GCP name: %1 in image coordinates GCPs container ").arg(gcpName);
                    return(false);
                }

                float eX=mGeometryGCPs[gcpName][6];
                float eY=mGeometryGCPs[gcpName][7];
                float eZ=mGeometryGCPs[gcpName][8];
                float e2d=mGeometryGCPs[gcpName][9];
                float e3d=sqrt(eX*eX+eY*eY+eZ*eZ);
                gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EX_COORDINATE,
                                                               QString::number(eX,'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION));
                gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EY_COORDINATE,
                                                               QString::number(eY,'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION));
                gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_EZ_COORDINATE,
                                                               QString::number(eZ,'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION));
                gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_E2D_COORDINATE,
                                                               QString::number(e2d,'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION));
                gcpNodes.at(nGcpNode).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_ATTRIBUTE_E3D_COORDINATE,
                                                               QString::number(e3d,'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION));

                for(int nPhoto=0;nPhoto<photoDataNodes.size();nPhoto++)
                {
                    QDomElement photoElement=photoDataNodes.at(nPhoto).toElement();
                    QString imageId=photoElement.attribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_NAME);
//                    bool toInt=false;
//                    int photo=imagePos.toInt(&toInt);
//                    if(!toInt)
//                    {
//                        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
//                        strError+=QObject::tr("\nFor GCP name: %1 error in image number: %2")
//                                .arg(gcpName)
//                                .arg(imagePos);
//                        return(false);
//                    }
////                    QString imageId=mImagesFileNameByPos[photo];
//                    QString imageId=photo;
                    if(!mImageCoordinatesGCPs[gcpName].contains(imageId))
                    {
                        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
                        strError+=QObject::tr("\nFor GCP name: %1 not exists coordinates in image: %2")
                                .arg(gcpName)
                                .arg(imageId);
                        return(false);
                    }
                    float exi=mImageCoordinatesGCPs[gcpName][imageId][3];
                    float eyi=mImageCoordinatesGCPs[gcpName][imageId][4];
                    float e2d=mImageCoordinatesGCPs[gcpName][imageId][5];
                    photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_EX_COORDINATE,
                                                                       QString::number(exi,'f',mImageCoordinatesPrecision+1));
                    photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_EY_COORDINATE,
                                                                       QString::number(eyi,'f',mImageCoordinatesPrecision+1));
                    photoDataNodes.at(nPhoto).toElement().setAttribute(ORTOSKYXMLMATCHESFILE_GCP_IMG_ATTRIBUTE_E2D_COORDINATE,
                                                                       QString::number(e2d,'f',mImageCoordinatesPrecision+1));
                }
            }
        }
    }
    const int IndentSize = 4;
    QFile file(mXmlFileName);
    if (!file.open(QFile::WriteOnly | QFile::Text))
    {
        strError=tr("Error opening xml file:\n%1").arg(mXmlFileName);
        return(false);
    }
    QTextStream out(&file);
    mDoc.save(out, IndentSize);
    return(true);
}

bool OrientationProcessMonitor::readOrientations(QDomElement& cameraModelXmlElement,
                                                 QMap<QString,QDomElement> &exteriorOrientationXmlElements,
                                                 QString& strError)
{
    QString orientationSuffix=mTapasDistModel;
    if(mImages.count() < 1)
    {
        strError=QObject::tr("Orientations read error: no images to read in orientations solution: %1").arg(orientationSuffix);
        return(false);
    }
    QDir auxDir=QDir::currentPath();
    if(!auxDir.exists(mTmpFolder))
    {
        strError=QObject::tr("Orientations read error: images path %1 not exists").arg(mImagesPath);
        return(false);
    }
    QString basePath=mTmpFolder+"/"+TAPIOCA_ORIENTATION_PREFIX_FOLDER+orientationSuffix;
    if(!auxDir.exists(basePath))
    {
        strError=QObject::tr("Orientations read error: orientation path %1 not exists").arg(basePath);
        return(false);
    }
    Camera *camera = mImages.at(0)->getCamera();
    AperoModelReader interiorReader(camera);
    QDir baseDir(basePath);
    QStringList files = baseDir.entryList(QStringList("AutoCal*.xml"), QDir::Files | QDir::NoSymLinks);

    if (!files.isEmpty() && !QFile::exists(basePath+"/"+files.at(0)))
    {
        strError=QObject::tr("Orientations read error: invalid solution in %1").arg(basePath);
        return(false);
    }
    CameraModel *cameraModel = interiorReader.read(basePath+"/"+files.at(0));
    if (cameraModel == NULL)
    {
        strError=QObject::tr("Orientations read error: invalid solution in %1").arg(basePath);
        return(false);
    }
    mCalibrationFileName=files.at(0);

    QVector<ExteriorOrientation *> extOris;
    MicMacEOReader exteriorReader;
    QString errorStr,noStr;
    int errorLine,errorColumn;
    QMap<QString,QDomElement> auxExteriorOrientationXmlElements;
    for (int i=0 ;i<mImages.count();i++)
    {
        QString orientationFileName=basePath+"/"+TAPIOCA_ORIENTATION_PREFIX_FILE+mImages.at(i)->getFileName()+TAPIOCA_ORIENTATION_EXTENSION_FILE;
        if(QFile::exists(orientationFileName))
        {
            ExteriorOrientation *extOri =  exteriorReader.read(orientationFileName);
            if (extOri == NULL)
            {
                strError=QObject::tr("Orientations %1 read error: invalid exterior orientation in file %2").arg(orientationSuffix).arg(orientationFileName);
                return(false);
            }
            extOris.push_back(extOri);
        }
        else // Nunca puede haber una imagen sin orientación incluso en seleccion de imagenes para calibración porque leo el segundo tapas
        {
            strError=QObject::tr("Orientations %1 read error: no exterior orientation for image: %2").arg(orientationSuffix).arg(mImages.at(i)->getFileName());
            return(false);
        }

        QFile eoModelXmlFile(orientationFileName);
        if (!eoModelXmlFile.open(QIODevice::ReadOnly))
        {
            strError=QObject::tr("Orientations %1 read error: error opening xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            return(false);
        }
        QDomDocument eoXmlDoc;
        if (!eoXmlDoc.setContent(&eoModelXmlFile,true,&errorStr,&errorLine,&errorColumn))
        {
            strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
            eoModelXmlFile.close();
            return(false);
        }
        eoModelXmlFile.close();
        QDomNodeList eosModelNodeList=eoXmlDoc.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        if(eosModelNodeList.size()!=1)
        {
            strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            strError+=QObject::tr("\nThere are more than one ExportAPERO node");
            return(false);
        }
        auxExteriorOrientationXmlElements[mImages.at(i)->getFileName()]=eosModelNodeList.at(0).toElement();
    }
//    for (int i = 0; i<getCameras().count(); i++)
//        getCameras().at(i)->setCameraModel(cameraModel);
    QFile cameraModelXmlFile(basePath+"/"+files.at(0));
    if (!cameraModelXmlFile.open(QIODevice::ReadOnly))
    {
        strError=QObject::tr("Orientations %1 read error: error opening xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        return(false);
    }
    QDomDocument cameraModelXmlDoc;
    if (!cameraModelXmlDoc.setContent(&cameraModelXmlFile,true,&errorStr,&errorLine,&errorColumn))
    {
        strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
        cameraModelXmlFile.close();
        return(false);
    }
    cameraModelXmlFile.close();
    QDomNodeList cameraModelNodeList=cameraModelXmlDoc.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
    if(cameraModelNodeList.size()!=1)
    {
        strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        strError+=QObject::tr("\nThere are more than one ExportAPERO node");
        return(false);
    }

    cameraModelXmlElement=cameraModelNodeList.at(0).toElement();
    exteriorOrientationXmlElements=auxExteriorOrientationXmlElements;
    for(int i=0;i<mImages.size();i++)
    {
        mImages.at(i)->getCamera()->setCameraModel(cameraModel);
    }
    for (int i=0 ;i<mImages.count();i++)
    {
        mImages.at(i)->setExteriorOrientation(extOris.at(i));
    }
    return(true);
}

bool OrientationProcessMonitor::readOrientations_201501(QDomElement& cameraModelXmlElement,
                                                        QMap<QString,QDomElement> &exteriorOrientationXmlElements,
                                                        QString& strError)
{
    QString orientationSuffix=mTapasDistModel;
    if(mImages.count() < 1)
    {
        strError=QObject::tr("Orientations read error: no images to read in orientations solution: %1").arg(orientationSuffix);
        return(false);
    }
    QDir auxDir=QDir::currentPath();
    if(!auxDir.exists(mImagesPath))
    {
        strError=QObject::tr("Orientations read error: images path %1 not exists").arg(mImagesPath);
        return(false);
    }
    QString basePath=mImagesPath+"/"+TAPIOCA_ORIENTATION_PREFIX_FOLDER+orientationSuffix;
    if(!auxDir.exists(basePath))
    {
        strError=QObject::tr("Orientations read error: orientation path %1 not exists").arg(basePath);
        return(false);
    }
    Camera *camera = mImages.at(0)->getCamera();
    AperoModelReader interiorReader(camera);
    QDir baseDir(basePath);
    QStringList files = baseDir.entryList(QStringList("AutoCal*.xml"), QDir::Files | QDir::NoSymLinks);

    if (!files.isEmpty() && !QFile::exists(basePath+"/"+files.at(0)))
    {
        strError=QObject::tr("Orientations read error: invalid solution in %1").arg(basePath);
        return(false);
    }
    CameraModel *cameraModel = interiorReader.read(basePath+"/"+files.at(0));
    if (cameraModel == NULL)
    {
        strError=QObject::tr("Orientations read error: invalid solution in %1").arg(basePath);
        return(false);
    }
    mCalibrationFileName=files.at(0);

    QVector<ExteriorOrientation *> extOris;
    MicMacEOReader exteriorReader;
    QString errorStr,noStr;
    int errorLine,errorColumn;
    QMap<QString,QDomElement> auxExteriorOrientationXmlElements;
    for (int i=0 ;i<mImages.count();i++)
    {
        QString orientationFileName=basePath+"/"+TAPIOCA_ORIENTATION_PREFIX_FILE+mImages.at(i)->getFileName()+TAPIOCA_ORIENTATION_EXTENSION_FILE;
        if(QFile::exists(orientationFileName))
        {
            ExteriorOrientation *extOri =  exteriorReader.read(orientationFileName);
            if (extOri == NULL)
            {
                strError=QObject::tr("Orientations %1 read error: invalid exterior orientation in file %2").arg(orientationSuffix).arg(orientationFileName);
                return(false);
            }
            extOris.push_back(extOri);
        }
        else // Nunca puede haber una imagen sin orientación incluso en seleccion de imagenes para calibración porque leo el segundo tapas
        {
            strError=QObject::tr("Orientations %1 read error: no exterior orientation for image: %2").arg(orientationSuffix).arg(mImages.at(i)->getFileName());
            return(false);
        }

        QFile eoModelXmlFile(orientationFileName);
        if (!eoModelXmlFile.open(QIODevice::ReadOnly))
        {
            strError=QObject::tr("Orientations %1 read error: error opening xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            return(false);
        }
        QDomDocument eoXmlDoc;
        if (!eoXmlDoc.setContent(&eoModelXmlFile,true,&errorStr,&errorLine,&errorColumn))
        {
            strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
            eoModelXmlFile.close();
            return(false);
        }
        eoModelXmlFile.close();
        QDomNodeList eosModelNodeList=eoXmlDoc.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        if(eosModelNodeList.size()!=1)
        {
            strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(orientationFileName);
            strError+=QObject::tr("\nThere are more than one ExportAPERO node");
            return(false);
        }
        auxExteriorOrientationXmlElements[mImages.at(i)->getFileName()]=eosModelNodeList.at(0).toElement();
    }
//    for (int i = 0; i<getCameras().count(); i++)
//        getCameras().at(i)->setCameraModel(cameraModel);
    QFile cameraModelXmlFile(basePath+"/"+files.at(0));
    if (!cameraModelXmlFile.open(QIODevice::ReadOnly))
    {
        strError=QObject::tr("Orientations %1 read error: error opening xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        return(false);
    }
    QDomDocument cameraModelXmlDoc;
    if (!cameraModelXmlDoc.setContent(&cameraModelXmlFile,true,&errorStr,&errorLine,&errorColumn))
    {
        strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
        cameraModelXmlFile.close();
        return(false);
    }
    cameraModelXmlFile.close();
    QDomNodeList cameraModelNodeList=cameraModelXmlDoc.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
    if(cameraModelNodeList.size()!=1)
    {
        strError=QObject::tr("Orientations %1 read error: error reading xml file:\n%2").arg(orientationSuffix).arg(basePath+"/"+files.at(0));
        strError+=QObject::tr("\nThere are more than one ExportAPERO node");
        return(false);
    }

    cameraModelXmlElement=cameraModelNodeList.at(0).toElement();
    exteriorOrientationXmlElements=auxExteriorOrientationXmlElements;
    for(int i=0;i<mImages.size();i++)
    {
        mImages.at(i)->getCamera()->setCameraModel(cameraModel);
    }
    for (int i=0 ;i<mImages.count();i++)
    {
        mImages.at(i)->setExteriorOrientation(extOris.at(i));
    }
    return(true);
}

bool OrientationProcessMonitor::readOrientationsSDGAP(QDomElement& cameraModelXmlElement,
                                                      QDomElement & imageOrientationsElement,
                                                      QString& strError)
{
    QString calibrationId=cameraModelXmlElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID).trimmed();

    // Lectura de la orientacion interna
    cameraModelXmlElement=mInputCalibrationXmlElement;
    Camera *camera = mImages.at(0)->getCamera();
    AperoModelReader interiorReader(camera);
    QDomElement auxCameraModelXmlElement;
    {
        QDomNodeList auxNodes=cameraModelXmlElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        QDomNode calibrationNode=auxNodes.at(0);
        auxCameraModelXmlElement=calibrationNode.toElement();
    }
    CameraModel *cameraModel = interiorReader.read(auxCameraModelXmlElement);
    if (cameraModel == NULL)
    {
        strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading interior orientation id:\n%1").arg(calibrationId);
        return(false);
    }
    QString cameraType=LIBSDGAP_CAMERA_TYPE_CCD;
    //QString cameraId=camera->getName()+"_"+calibrationId;
    QString cameraId=camera->getName();
    QString cameraComment=camera->getName();
    int columns=mSensorSize.width();
    int rows=mSensorSize.height();
    double xPixelSize_mm=camera->getSensorWidth()/((double)columns); // en mm
    double yPixelSize_mm=camera->getSensorHeight()/((double)rows); // en mm
    double focal_mm,xPPA_mm,yPPA_mm;
    double k1_mm=0.0;
    double k2_mm=0.0;
    double k3_mm=0.0;
    double p1_mm=0.0;
    double p2_mm=0.0;
    double b1_mm=0.0;
    double b2_mm=0.0;
    if(!mLibSDGAP->getPBAResults(focal_mm,xPPA_mm,yPPA_mm,k1_mm,k2_mm,k3_mm,p1_mm,p2_mm,b1_mm,b2_mm,strError))
    {
        strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading results from SDGAP");
        return(false);
    }
    double focal_pixel=focal_mm/xPixelSize_mm;
    double xPPA_pixel=((double)columns)/2.0+xPPA_mm/xPixelSize_mm;
    //double yPPA_pixel=(double)rows-(((double)rows)/2.0+yPPA_mm/xPixelSize_mm); // equivalente a:
    double yPPA_pixel=((double)rows)/2.0-yPPA_mm/xPixelSize_mm;
//    double xPixelSize_mc=xPixelSize_mm*1e+3;
//    double yPixelSize_mc=yPixelSize_mm*1e+3;
    double k1_pixel=k1_mm*pow(xPixelSize_mm,2.0)*pow(xPixelSize_mm,2.0);
    double k2_pixel=k2_mm*pow(xPixelSize_mm,4.0)*pow(xPixelSize_mm,4.0);
    double k3_pixel=k3_mm*pow(xPixelSize_mm,6.0)*pow(xPixelSize_mm,6.0);
    double p1_pixel=p1_mm*xPixelSize_mm;//*xPixelSize_mm;
    double p2_pixel=p2_mm*xPixelSize_mm;//*xPixelSize_mm;
    double b1_pixel=b1_mm;//*xPixelSize_mm;
    double b2_pixel=b2_mm;//*xPixelSize_mm;
    //PW::FraserModel *distortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
    PW::FraserModel *distortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
    bool findDistortionModel=false;
    if(distortionModel!=NULL)
    {
        if(!distortionModel->isBasic())
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, orientation input is not Fraser basic:\n%1").arg(calibrationId);
            return(false);
        }
        findDistortionModel=true;
    }

    // Actualización de la orientación interna de las imágenes para el cálculo posterior de precisiones
    for(int nI=0;nI<mImages.size();nI++)
    {
        Camera *imageCamera = mImages.at(nI)->getCamera();
        CameraModel* imageCameraModel=imageCamera->getCameraModel();
        ((PW::PhotogrammetricModel*)imageCameraModel)->setFocal(focal_pixel);
        ((PW::PhotogrammetricModel*)imageCameraModel)->setXp(xPPA_pixel);
        ((PW::PhotogrammetricModel*)imageCameraModel)->setYp(yPPA_pixel);
        PW::FraserModel *imageDistortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)imageCameraModel)->getDistortionModel());
        imageDistortionModel->setXcd(xPPA_pixel);
        imageDistortionModel->setXcd(yPPA_pixel);
        imageDistortionModel->setK1(k1_pixel);
        imageDistortionModel->setK2(k2_pixel);
        imageDistortionModel->setK3(k3_pixel);
        imageDistortionModel->setP1(p1_pixel);
        imageDistortionModel->setP2(p2_pixel);
        imageDistortionModel->setB1(b1_pixel);
        imageDistortionModel->setB2(b2_pixel);
    }

    // Actualización de la orientación interna para su almacenamiento posterior en XML
    QDomNodeList ppNodes=cameraModelXmlElement.elementsByTagName("PP");
    QDomNode ppNode=ppNodes.at(0);
    QDomNode ppNewNode=ppNode;
    QString ppNodeValue=QString::number(xPPA_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION)
            +" "+QString::number(yPPA_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    ppNewNode.firstChild().setNodeValue(ppNodeValue);
    cameraModelXmlElement.replaceChild(ppNewNode,ppNode);

    QDomNodeList focalNodes=cameraModelXmlElement.elementsByTagName("F");
    QDomNode focalNode=focalNodes.at(0);
    QDomNode focalNewNode=focalNode;
    QString focalNodeValue=QString::number(focal_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    focalNewNode.firstChild().setNodeValue(focalNodeValue);
    cameraModelXmlElement.replaceChild(focalNewNode,focalNode);

    QDomNodeList cDistNodes=cameraModelXmlElement.elementsByTagName("CDist");
    QDomNode cDistNode=cDistNodes.at(0);
    QDomNode cDistNewNode=cDistNode;
    cDistNewNode.firstChild().setNodeValue(ppNodeValue);
    cameraModelXmlElement.replaceChild(cDistNewNode,cDistNode);

    QDomNodeList p1Nodes=cameraModelXmlElement.elementsByTagName("P1");
    QDomNode p1Node=p1Nodes.at(0);
    QDomNode p1NewNode=p1Node;
    QString p1NodeValue=QString::number(p1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    p1NewNode.firstChild().setNodeValue(p1NodeValue);
    cameraModelXmlElement.replaceChild(p1NewNode,p1Node);

    QDomNodeList p2Nodes=cameraModelXmlElement.elementsByTagName("P2");
    QDomNode p2Node=p2Nodes.at(0);
    QDomNode p2NewNode=p2Node;
    QString p2NodeValue=QString::number(p2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    p2NewNode.firstChild().setNodeValue(p2NodeValue);
    cameraModelXmlElement.replaceChild(p2NewNode,p2Node);

    QDomNodeList b1Nodes=cameraModelXmlElement.elementsByTagName("b1");
    QDomNode b1Node=b1Nodes.at(0);
    QDomNode b1NewNode=b1Node;
    QString b1NodeValue=QString::number(b1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    b1NewNode.firstChild().setNodeValue(b1NodeValue);
    cameraModelXmlElement.replaceChild(b1NewNode,b1Node);

    QDomNodeList b2Nodes=cameraModelXmlElement.elementsByTagName("b2");
    QDomNode b2Node=b2Nodes.at(0);
    QDomNode b2NewNode=b2Node;
    QString b2NodeValue=QString::number(b2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    b2NewNode.firstChild().setNodeValue(b2NodeValue);
    cameraModelXmlElement.replaceChild(b2NewNode,b2Node);

    QDomNodeList coeffDistNodes=cameraModelXmlElement.elementsByTagName("CoeffDist");
    for(int nc=0;nc<coeffDistNodes.size();nc++)
    {
        QDomNode kDistNode=coeffDistNodes.at(nc);
        QString kNodeValue;
        if(nc==0)
            kNodeValue=QString::number(k1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else if(nc==1)
            kNodeValue=QString::number(k2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else if(nc==2)
            kNodeValue=QString::number(k3_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else
            kNodeValue=QString::number(0.0,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        QDomNode kNewDistNode=kDistNode;
        kNewDistNode.firstChild().setNodeValue(kNodeValue);
        cameraModelXmlElement.replaceChild(kNewDistNode,kDistNode);
    }

    QString outputCalibration=mTargetOrientation;
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID,
                                       outputCalibration);
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,
                                       PBA_COMPUTATIONS_ENGINE_SDGAP);
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,
                                       APERO_CALIBRATION_MODEL_FRASER_BASIC);

    // Lectura de las orientaciones externas
    imageOrientationsElement=mImageOrientationXmlElement;
    imageOrientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID,
                                         outputCalibration);
    QDomNodeList imageOrientationNodes=imageOrientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
    for(int no=0;no<imageOrientationNodes.size();no++)
    {
        QDomElement imageOrientationElement=imageOrientationNodes.at(no).toElement();
        QString imageId=imageOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_ID);
        PWImage* image=NULL;
        for(int nI=0;nI<mImages.size();nI++)
        {
            if(imageId.compare(mImages[nI]->getFileName(),Qt::CaseInsensitive)==0)
            {
                image=mImages[nI];
                break;
            }
        }

        if(image==NULL)
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, image: %1 not found").arg(imageId);
            return(false);
        }
        QVector< QVector<double> > r;// = firstImage->getExteriorOrientation()->getR();
        QVector<double> cp;// = firstImage->getExteriorOrientation()->getCP();
        if(!mLibSDGAP->getPBAResultsExteriorOrientation(imageId,r,cp,strError))
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading results from SDGAP");
            return(false);
        }

        // Actualización de la orientación externa de la imagen para el posterior cálculo de precisiones
        ExteriorOrientation* extOri=image->getExteriorOrientation();
        extOri->setCP(cp);
        QVector<QVector<double> > rAperoFormat=r;
        rAperoFormat[0][1]=-1.0*rAperoFormat[0][1];
        rAperoFormat[0][2]=-1.0*rAperoFormat[0][2];
        rAperoFormat[1][1]=-1.0*rAperoFormat[1][1];
        rAperoFormat[1][2]=-1.0*rAperoFormat[1][2];
        rAperoFormat[2][1]=-1.0*rAperoFormat[2][1];
        rAperoFormat[2][2]=-1.0*rAperoFormat[2][2];
        extOri->setR(rAperoFormat);

        // Actualización para almacenamiento posterior en xml
        QDomNodeList centreNodes=imageOrientationElement.elementsByTagName("Centre");
        QDomNode centreNode=centreNodes.at(0);
        QDomNode centreNewNode=centreNode;
        QString centreNodeValue=QString::number(cp[0],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION)
                +" "+QString::number(cp[1],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION)
                +" "+QString::number(cp[2],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION);
        centreNewNode.firstChild().setNodeValue(centreNodeValue);
        imageOrientationElement.replaceChild(centreNewNode,centreNode);

        QDomNodeList l1Nodes=imageOrientationElement.elementsByTagName("L1");
        QDomNode l1Node=l1Nodes.at(0);
        QDomNode l1NewNode=l1Node;
        QString l1NodeValue=QString::number(r[0][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[0][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[0][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l1NewNode.firstChild().setNodeValue(l1NodeValue);
        imageOrientationElement.replaceChild(l1NewNode,l1Node);

        QDomNodeList l2Nodes=imageOrientationElement.elementsByTagName("L2");
        QDomNode l2Node=l2Nodes.at(0);
        QDomNode l2NewNode=l2Node;
        QString l2NodeValue=QString::number(r[1][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[1][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[1][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l2NewNode.firstChild().setNodeValue(l2NodeValue);
        imageOrientationElement.replaceChild(l2NewNode,l2Node);

        QDomNodeList l3Nodes=imageOrientationElement.elementsByTagName("L3");
        QDomNode l3Node=l3Nodes.at(0);
        QDomNode l3NewNode=l3Node;
        QString l3NodeValue=QString::number(r[2][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[2][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[2][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l3NewNode.firstChild().setNodeValue(l3NodeValue);
        imageOrientationElement.replaceChild(l3NewNode,l3Node);
    }
    return(true);
}

bool OrientationProcessMonitor::readOrientationsSDGAPFromOrtoSkyXml(QDomElement &cameraModelXmlElement,
                                                                    QMap<QString,QDomElement> &imageOrientationsElements,
                                                                    QString &strError)
{
    QString calibrationId=cameraModelXmlElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID).trimmed();
    imageOrientationsElements.clear();

    // Lectura de la orientacion interna
    cameraModelXmlElement=mInputCalibrationXmlElement;
    Camera *camera = mImages.at(0)->getCamera();
    AperoModelReader interiorReader(camera);
    QDomElement auxCameraModelXmlElement;
    {
        QDomNodeList auxNodes=cameraModelXmlElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        QDomNode calibrationNode=auxNodes.at(0);
        auxCameraModelXmlElement=calibrationNode.toElement();
    }
    CameraModel *cameraModel = interiorReader.read(auxCameraModelXmlElement);
    if (cameraModel == NULL)
    {
        strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading interior orientation id:\n%1").arg(calibrationId);
        return(false);
    }
    QString cameraType=LIBSDGAP_CAMERA_TYPE_CCD;
    //QString cameraId=camera->getName()+"_"+calibrationId;
    QString cameraId=camera->getName();
    QString cameraComment=camera->getName();
    int columns=mSensorSize.width();
    int rows=mSensorSize.height();
    double xPixelSize_mm=camera->getSensorWidth()/((double)columns); // en mm
    double yPixelSize_mm=camera->getSensorHeight()/((double)rows); // en mm
    double focal_mm,xPPA_mm,yPPA_mm;
    double k1_mm=0.0;
    double k2_mm=0.0;
    double k3_mm=0.0;
    double p1_mm=0.0;
    double p2_mm=0.0;
    double b1_mm=0.0;
    double b2_mm=0.0;
    if(!mLibSDGAP->getPBAResults(focal_mm,xPPA_mm,yPPA_mm,k1_mm,k2_mm,k3_mm,p1_mm,p2_mm,b1_mm,b2_mm,strError))
    {
        strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading results from SDGAP");
        return(false);
    }
    double focal_pixel=focal_mm/xPixelSize_mm;
    double xPPA_pixel=((double)columns)/2.0+xPPA_mm/xPixelSize_mm;
    //double yPPA_pixel=(double)rows-(((double)rows)/2.0+yPPA_mm/xPixelSize_mm); // equivalente a:
    double yPPA_pixel=((double)rows)/2.0-yPPA_mm/xPixelSize_mm;
//    double xPixelSize_mc=xPixelSize_mm*1e+3;
//    double yPixelSize_mc=yPixelSize_mm*1e+3;
    double k1_pixel=k1_mm*pow(xPixelSize_mm,2.0)*pow(xPixelSize_mm,2.0);
    double k2_pixel=k2_mm*pow(xPixelSize_mm,4.0)*pow(xPixelSize_mm,4.0);
    double k3_pixel=k3_mm*pow(xPixelSize_mm,6.0)*pow(xPixelSize_mm,6.0);
    double p1_pixel=p1_mm*xPixelSize_mm*xPixelSize_mm;
    double p2_pixel=p2_mm*xPixelSize_mm*xPixelSize_mm;
    double b1_pixel=b1_mm;//*xPixelSize_mm;
    double b2_pixel=b2_mm;//*xPixelSize_mm;
    //PW::FraserModel *distortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
    PW::FraserModel *distortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)cameraModel)->getDistortionModel());
    bool findDistortionModel=false;
    if(distortionModel!=NULL)
    {
        if(!distortionModel->isBasic())
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, orientation input is not Fraser basic:\n%1").arg(calibrationId);
            return(false);
        }
        findDistortionModel=true;
    }

    // Actualización de la orientación interna de las imágenes para el cálculo posterior de precisiones
    for(int nI=0;nI<mImages.size();nI++)
    {
        Camera *imageCamera = mImages.at(nI)->getCamera();
        CameraModel* imageCameraModel=imageCamera->getCameraModel();
        ((PW::PhotogrammetricModel*)imageCameraModel)->setFocal(focal_pixel);
        ((PW::PhotogrammetricModel*)imageCameraModel)->setXp(xPPA_pixel);
        ((PW::PhotogrammetricModel*)imageCameraModel)->setYp(yPPA_pixel);
        PW::FraserModel *imageDistortionModel = dynamic_cast<PW::FraserModel*>(((PW::PhotogrammetricModel*)imageCameraModel)->getDistortionModel());
        imageDistortionModel->setXcd(xPPA_pixel);
        imageDistortionModel->setYcd(yPPA_pixel);
        imageDistortionModel->setK1(k1_pixel);
        imageDistortionModel->setK2(k2_pixel);
        imageDistortionModel->setK3(k3_pixel);
        imageDistortionModel->setP1(p1_pixel);
        imageDistortionModel->setP2(p2_pixel);
        imageDistortionModel->setB1(b1_pixel);
        imageDistortionModel->setB2(b2_pixel);
    }

    // Actualización de la orientación interna para su almacenamiento posterior en XML
    QDomNodeList ppNodes=cameraModelXmlElement.elementsByTagName("PP");
    QDomNode ppNode=ppNodes.at(0);
    QDomNode ppNewNode=ppNode;
    QString ppNodeValue=QString::number(xPPA_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION)
            +" "+QString::number(yPPA_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    ppNewNode.firstChild().setNodeValue(ppNodeValue);
    cameraModelXmlElement.replaceChild(ppNewNode,ppNode);

    QDomNodeList focalNodes=cameraModelXmlElement.elementsByTagName("F");
    QDomNode focalNode=focalNodes.at(0);
    QDomNode focalNewNode=focalNode;
    QString focalNodeValue=QString::number(focal_pixel,'f',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    focalNewNode.firstChild().setNodeValue(focalNodeValue);
    cameraModelXmlElement.replaceChild(focalNewNode,focalNode);

    QDomNodeList cDistNodes=cameraModelXmlElement.elementsByTagName("CDist");
    QDomNode cDistNode=cDistNodes.at(0);
    QDomNode cDistNewNode=cDistNode;
    cDistNewNode.firstChild().setNodeValue(ppNodeValue);
    cameraModelXmlElement.replaceChild(cDistNewNode,cDistNode);

    QDomNodeList p1Nodes=cameraModelXmlElement.elementsByTagName("P1");
    QDomNode p1Node=p1Nodes.at(0);
    QDomNode p1NewNode=p1Node;
    QString p1NodeValue=QString::number(p1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    p1NewNode.firstChild().setNodeValue(p1NodeValue);
    cameraModelXmlElement.replaceChild(p1NewNode,p1Node);

    QDomNodeList p2Nodes=cameraModelXmlElement.elementsByTagName("P2");
    QDomNode p2Node=p2Nodes.at(0);
    QDomNode p2NewNode=p2Node;
    QString p2NodeValue=QString::number(p2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    p2NewNode.firstChild().setNodeValue(p2NodeValue);
    cameraModelXmlElement.replaceChild(p2NewNode,p2Node);

    QDomNodeList b1Nodes=cameraModelXmlElement.elementsByTagName("b1");
    QDomNode b1Node=b1Nodes.at(0);
    QDomNode b1NewNode=b1Node;
    QString b1NodeValue=QString::number(b1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    b1NewNode.firstChild().setNodeValue(b1NodeValue);
    cameraModelXmlElement.replaceChild(b1NewNode,b1Node);

    QDomNodeList b2Nodes=cameraModelXmlElement.elementsByTagName("b2");
    QDomNode b2Node=b2Nodes.at(0);
    QDomNode b2NewNode=b2Node;
    QString b2NodeValue=QString::number(b2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
    b2NewNode.firstChild().setNodeValue(b2NodeValue);
    cameraModelXmlElement.replaceChild(b2NewNode,b2Node);

    QDomNodeList coeffDistNodes=cameraModelXmlElement.elementsByTagName("CoeffDist");
    for(int nc=0;nc<coeffDistNodes.size();nc++)
    {
        QDomNode kDistNode=coeffDistNodes.at(nc);
        QString kNodeValue;
        if(nc==0)
            kNodeValue=QString::number(k1_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else if(nc==1)
            kNodeValue=QString::number(k2_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else if(nc==2)
            kNodeValue=QString::number(k3_pixel,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        else
            kNodeValue=QString::number(0.0,'g',EXTERNALINTERFACEPROCESSMONITOR_PIXEL_PRECISION);
        QDomNode kNewDistNode=kDistNode;
        kNewDistNode.firstChild().setNodeValue(kNodeValue);
        cameraModelXmlElement.replaceChild(kNewDistNode,kDistNode);
    }

    QString outputCalibration=mTargetOrientation;
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID,
                                       outputCalibration);
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,
                                       PBA_COMPUTATIONS_ENGINE_SDGAP);
    cameraModelXmlElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,
                                       APERO_CALIBRATION_MODEL_FRASER_BASIC);

    // Lectura de las orientaciones externas
//    QDomElement imageOrientationsElement=mImageOrientationXmlElement;
//    imageOrientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID,
//                                         outputCalibration);
//    QDomNodeList imageOrientationNodes=imageOrientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
//    for(int no=0;no<imageOrientationNodes.size();no++)
//    {
//            QDomElement imageOrientationElement=imageOrientationNodes.at(no).toElement();
//            QString imageId=imageOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME);
    QMap<QString,QDomElement>::iterator iter= mSourceImageOrientationsXmlElements.begin();
    while(iter!=mSourceImageOrientationsXmlElements.end())
    {
        QString imageId=iter.key();
        QDomElement imageOrientationElement=iter.value();
        PWImage* image=NULL;
        if(mImagesByName.contains(imageId))
            image=mImagesByName[imageId];
        if(image==NULL)
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, image: %1 not found").arg(imageId);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageId];
        QVector< QVector<double> > r;// = firstImage->getExteriorOrientation()->getR();
        QVector<double> cp;// = firstImage->getExteriorOrientation()->getCP();
        if(!mLibSDGAP->getPBAResultsExteriorOrientation(imageId,r,cp,strError))
        {
            strError=QObject::tr("OrientationProcessMonitor::readOrientationsSDGAP, error reading results from SDGAP");
            return(false);
        }

        // Actualización de la orientación externa de la imagen para el posterior cálculo de precisiones
        ExteriorOrientation* extOri=image->getExteriorOrientation();
        extOri->setCP(cp);
        QVector<QVector<double> > rAperoFormat=r;
        rAperoFormat[0][1]=-1.0*rAperoFormat[0][1];
        rAperoFormat[0][2]=-1.0*rAperoFormat[0][2];
        rAperoFormat[1][1]=-1.0*rAperoFormat[1][1];
        rAperoFormat[1][2]=-1.0*rAperoFormat[1][2];
        rAperoFormat[2][1]=-1.0*rAperoFormat[2][1];
        rAperoFormat[2][2]=-1.0*rAperoFormat[2][2];
        extOri->setR(rAperoFormat);

        // Actualización para almacenamiento posterior en xml
        QDomNodeList centreNodes=imageOrientationElement.elementsByTagName("Centre");
        QDomNode centreNode=centreNodes.at(0);
        QDomNode centreNewNode=centreNode;
        QString centreNodeValue=QString::number(cp[0],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION)
                +" "+QString::number(cp[1],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION)
                +" "+QString::number(cp[2],'f',EXTERNALINTERFACEPROCESSMONITOR_TERRAIN_PRECISION);
        centreNewNode.firstChild().setNodeValue(centreNodeValue);
        imageOrientationElement.replaceChild(centreNewNode,centreNode);

        QDomNodeList l1Nodes=imageOrientationElement.elementsByTagName("L1");
        QDomNode l1Node=l1Nodes.at(0);
        QDomNode l1NewNode=l1Node;
        QString l1NodeValue=QString::number(r[0][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[0][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[0][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l1NewNode.firstChild().setNodeValue(l1NodeValue);
        imageOrientationElement.replaceChild(l1NewNode,l1Node);

        QDomNodeList l2Nodes=imageOrientationElement.elementsByTagName("L2");
        QDomNode l2Node=l2Nodes.at(0);
        QDomNode l2NewNode=l2Node;
        QString l2NodeValue=QString::number(r[1][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[1][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[1][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l2NewNode.firstChild().setNodeValue(l2NodeValue);
        imageOrientationElement.replaceChild(l2NewNode,l2Node);

        QDomNodeList l3Nodes=imageOrientationElement.elementsByTagName("L3");
        QDomNode l3Node=l3Nodes.at(0);
        QDomNode l3NewNode=l3Node;
        QString l3NodeValue=QString::number(r[2][0],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[2][1],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION)
                +" "+QString::number(-1.0*r[2][2],'f',EXTERNALINTERFACEPROCESSMONITOR_ROTATION_MATRIX_PRECISION);
        l3NewNode.firstChild().setNodeValue(l3NodeValue);
        imageOrientationElement.replaceChild(l3NewNode,l3Node);
        imageOrientationsElements[imageFileNameWithoutPath]=imageOrientationElement;
        iter++;
    }
    return(true);
}

bool OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile_201501(QString &strError)
{
    if(!mIsInitialized)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n");
        strError+=QObject::tr("OrientationProcessMonitor is not initialized");
        return(false);
    }

    // Lectura de los parámetros del ajuste
    QDomNodeList bundleAdjustmentParametersNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS);
    if(bundleAdjustmentParametersNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag camera in the file");
        return(false);
    }
    if(bundleAdjustmentParametersNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one camera node");
        return(false);
    }
    QDomNode bundleAdjustmentParametersNode=bundleAdjustmentParametersNodes.at(0);
    QDomElement bundleAdjustmentParametersElement=bundleAdjustmentParametersNode.toElement();

    bool okToInt=false;
    bool okToDouble=false;
    QString strValue;
    int intValue;
    double dblValue;

    // Lectura del número de imágenes a usar
    QDomNodeList numberOfImagesToUseNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
    if(numberOfImagesToUseNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    if(numberOfImagesToUseNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    QDomNode numberOfImagesToUseNode=numberOfImagesToUseNodes.at(0);
    strValue=numberOfImagesToUseNode.toElement().text();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    if(strValue.compare(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_ALL,Qt::CaseInsensitive)==0)
        mNumberOfImagesToUse=-1;
    else
    {
        intValue=strValue.toInt(&okToInt);
        if(!okToInt)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer or All").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
            return(false);
        }
        if(intValue<ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_MIN_VALUE||intValue>(mImages.size()-1))
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                    .arg(strValue)
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE)
                    .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_MIN_VALUE))
                    .arg(mImages.size());
            return(false);
        }
        mNumberOfImagesToUse=intValue;
    }

    // Lectura de la orientación origen
    QDomNodeList sourceOrientationNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
    if(sourceOrientationNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
        return(false);
    }
    if(sourceOrientationNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %s node").arg(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
        return(false);
    }
    QDomNode sourceOrientationNode=sourceOrientationNodes.at(0);
    strValue=sourceOrientationNode.toElement().text().trimmed();
    if(strValue.isEmpty())
        strValue=ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION_NO_INPUT;
    mSourceOrientation=strValue;
    // Comprobación de que existe?

    // Lectura de la orientación destino
    QDomNodeList targetOrientationNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_TARGET_ORIENTATION);
    if(targetOrientationNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_TARGET_ORIENTATION);
        return(false);
    }
    if(targetOrientationNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_TARGET_ORIENTATION);
        return(false);
    }
    QDomNode targetOrientationNode=targetOrientationNodes.at(0);
    strValue=targetOrientationNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_TARGET_ORIENTATION);
        return(false);
    }
    mTargetOrientation=strValue;

    // Lectura del modelo de calibración
    QDomNodeList calibrationModelIdNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ID);
    if(calibrationModelIdNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ID);
        return(false);
    }
    if(calibrationModelIdNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ID);
        return(false);
    }
    QDomNode calibrationModelIdNode=calibrationModelIdNodes.at(0);
    strValue=calibrationModelIdNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ID);
        return(false);
    }
    if(!mPBACalibrationModels.contains(strValue))
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid calibration model id: %1").arg(strValue);
        return(false);
    }
    mCalibrationModelId=strValue;
    mPBACalibrationModel=mPBACalibrationModels[strValue];
    mTapasDistModel = mPBACalibrationModel->getAperoId();
    mIsDGAPEngine=false;
    mPBAEngine=PBA_COMPUTATIONS_ENGINE_APERO;
    mPrintTiePointsAccuracies=false;
    if(mPBACalibrationModel->getIsSDGAP())
    {
        mPBAEngine=PBA_COMPUTATIONS_ENGINE_SDGAP;
        mIsDGAPEngine=true;
    }
    else
        mPBAEngine=PBA_COMPUTATIONS_ENGINE_APERO;
    if(mIsDGAPEngine)
    {
        if(mTapasDistModel.compare(APERO_CALIBRATION_MODEL_FRASER_BASIC)!=0)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nCalibration model: %1 is not valid for engine: %2").arg(mTapasDistModel).arg(mPBAEngine);
            return(false);
        }
    }
    if(mNumberOfImagesToUse!=-1) // no todas
    {
        if(mIsDGAPEngine)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError=QObject::tr("\nInvalid option: SDAG and a subset of images");
            return(false);
        }
    }

    // Lectura de creación de ply
    QDomNodeList createPlyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY);
    if(createPlyNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY);
        return(false);
    }
    if(createPlyNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %s node").arg(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY);
        return(false);
    }
    QDomNode createPlyNode=createPlyNodes.at(0);
    strValue=createPlyNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CREATE_PLY)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==0)
        mCreatePly=false;
    else
        mCreatePly=true;

    // Lectura de usar ground control
    QDomNodeList useGroundControlNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
    if(useGroundControlNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    if(useGroundControlNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %s node").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    QDomNode useGroundControlNode=useGroundControlNodes.at(0);
    strValue=useGroundControlNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%d,%d]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==0)
        mUseGroundControl=false;
    else
        mUseGroundControl=true;

    // Lectura de parámetros para la selección automática de TiePoints
    QDomNodeList parametersForAutomaticSelectionOfTiePointsNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
    if(parametersForAutomaticSelectionOfTiePointsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
        return(false);
    }
    if(parametersForAutomaticSelectionOfTiePointsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
        return(false);
    }
    QDomElement parametersForAutomaticSelectionOfTiePointsNode=parametersForAutomaticSelectionOfTiePointsNodes.at(0).toElement();
    QDomNodeList standardDeviationThresholdNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
    if(standardDeviationThresholdNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    if(standardDeviationThresholdNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    QDomNode standardDeviationThresholdNode=standardDeviationThresholdNodes.at(0);
    strValue=standardDeviationThresholdNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    dblValue=strValue.toDouble(&okToDouble);
    if(!okToDouble)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not a double").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    if(dblValue<ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MIN_VALUE
            ||dblValue>ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MIN_VALUE,'f',2))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MAX_VALUE,'f',2));
        return(false);
    }
    mStandardDesviationThreshold=dblValue;
    QDomNodeList ccdGridSizeNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
    if(ccdGridSizeNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    if(ccdGridSizeNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    QDomNode ccdGridSizeNode=ccdGridSizeNodes.at(0);
    strValue=ccdGridSizeNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    QStringList strValues=strValue.split(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR);
    if(strValues.size()!=2)
    {
        strValues=strValue.split(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR_BIS);
        if(strValues.size()!=2)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nTag: %1 dont have to strings separated by %2")
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR);
            return(false);
        }
    }
    intValue=strValues.at(0).toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                .arg(strValues.at(0));
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(0))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE));
        return(false);
    }
    mColumnsCcdGridSize=intValue;
    intValue=strValues.at(1).toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                .arg(strValues.at(1));
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(1))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE));
        return(false);
    }
    mRowsCcdGridSize=intValue;
    if(mColumnsCcdGridSize!=mRowsCcdGridSize)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nAt this state of development columns and rows in CCD grid must be equal");
        return(false);
    }
    QDomNodeList numberOfTiePointsInEachImageNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
    if(numberOfTiePointsInEachImageNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    if(numberOfTiePointsInEachImageNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    QDomNode numberOfTiePointsInEachImageNode=numberOfTiePointsInEachImageNodes.at(0);
    strValue=numberOfTiePointsInEachImageNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE)
                .arg(strValue);
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MAX_VALUE));
        return(false);
    }
    mNumberOfTiePointsInEachImage=intValue;
    QDomNodeList printTiePointsAccuraciesNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
    if(printTiePointsAccuraciesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    if(printTiePointsAccuraciesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    QDomNode printTiePointsAccuraciesNode=printTiePointsAccuraciesNodes.at(0);
    strValue=printTiePointsAccuraciesNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS)
                .arg(strValue);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==1)
        mPrintTiePointsAccuracies=true;
    else
        mPrintTiePointsAccuracies=false;

    // Lectura de parámetros para mínimos cuadrados
    QDomNodeList leastSquaresParametersNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
    if(leastSquaresParametersNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
        return(false);
    }
    if(leastSquaresParametersNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
        return(false);
    }
    QDomElement leastSquaresParametersNode=leastSquaresParametersNodes.at(0).toElement();
    QDomNodeList prioriStandardDeviationOfUnitWeightNodes=leastSquaresParametersNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
    if(prioriStandardDeviationOfUnitWeightNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    if(prioriStandardDeviationOfUnitWeightNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    QDomNode prioriStandardDeviationOfUnitWeightNode=prioriStandardDeviationOfUnitWeightNodes.at(0);
    strValue=prioriStandardDeviationOfUnitWeightNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    dblValue=strValue.toDouble(&okToDouble);
    if(!okToDouble)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not a double").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    if(dblValue<ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MIN_VALUE
            ||dblValue>ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MIN_VALUE,'f',2))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MAX_VALUE,'f',2));
        return(false);
    }
    mPrioriStandardDeviationOfUnitWeight=dblValue*mXPixelSize_mm/1000.0;
    QDomNodeList maximumNumberOfIterationsNodes=leastSquaresParametersNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
    if(maximumNumberOfIterationsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    if(maximumNumberOfIterationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    QDomNode maximumNumberOfIterationsNode=maximumNumberOfIterationsNodes.at(0);
    strValue=maximumNumberOfIterationsNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS)
                .arg(strValue);
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(1))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MAX_VALUE));
        return(false);
    }
    mMaximumNumberOfIterations=intValue;

    // Lectura del fichero de resultados
    QDomNodeList resultsFileNameNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
    if(resultsFileNameNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
        return(false);
    }
    if(resultsFileNameNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
        return(false);
    }
    QDomNode resultsFileNameNode=resultsFileNameNodes.at(0);
    strValue=resultsFileNameNode.toElement().text().trimmed();
    mResultsFileName=mProjectPath+"/"+strValue;

    // Lectura de actualizar precisiones
    QDomNodeList updateAccuraciesNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
    if(updateAccuraciesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    if(updateAccuraciesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    QDomNode updateAccuraciesNode=updateAccuraciesNodes.at(0);
    strValue=updateAccuraciesNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==0)
        mUpdateAccuracies=false;
    else
        mUpdateAccuracies=true;

    if(mUseGroundControl&&mNumberOfImagesToUse!=-1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: ground control and number of images different to 'All'");
        return(false);
    }
    if(mUseGroundControl&&mSourceOrientation.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: ground control without input calibration");
        return(false);
    }
    if(mIsDGAPEngine&&!mUseGroundControl)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: SDAG without ground control");
        return(false);
    }

    return(true);
}

bool OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile(QString pbaName,
                                                                                       QString &strError)
{
    if(!mIsInitialized)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n");
        strError+=QObject::tr("OrientationProcessMonitor is not initialized");
        return(false);
    }
    mPbaName=pbaName;

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    // Lectura de los parámetros del ajuste
    QDomNodeList bundleAdjustmentsParametersNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENTS_PARAMETERS);
    if(bundleAdjustmentsParametersNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENTS_PARAMETERS);
        return(false);
    }
    if(bundleAdjustmentsParametersNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENTS_PARAMETERS);
        return(false);
    }
    QDomNode bundleAdjustmentsParametersNode=bundleAdjustmentsParametersNodes.at(0);
    QDomElement bundleAdjustmentsParametersElement=bundleAdjustmentsParametersNode.toElement();
    QDomElement bundleAdjustmentParametersElement;
    QDomNodeList bundleAdjustmentParameterNodes=bundleAdjustmentsParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS);
    if(bundleAdjustmentParameterNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node %1").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS);
        return(false);
    }
    bool findPbaName=false;
    for(int nPbaNode=0;nPbaNode<bundleAdjustmentParameterNodes.size();nPbaNode++)
    {
        QDomNode bundleAdjustmentParameterNode=bundleAdjustmentParameterNodes.at(nPbaNode);
        QDomElement auxPbaElement=bundleAdjustmentParameterNode.toElement();
        QString pbaName=auxPbaElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS_ATTRIBUTE_NAME).trimmed();
        if(pbaName.compare(mPbaName,Qt::CaseInsensitive)==0)
        {
            if(findPbaName)
            {
                strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode %1 with name %2 is repeat").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS).arg(mSessionName);
                return(false);
            }
            bundleAdjustmentParametersElement=auxPbaElement;
            findPbaName=true;
        }
    }
    if(!findPbaName)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node %1 with name %2").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS).arg(mPbaName);
        return(false);
    }

    QString targetOrientation=bundleAdjustmentParametersElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS_ATTRIBUTE_TARGET_ORIENTATION).trimmed();
    if(targetOrientation.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nIn node %1 with name %1").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS).arg(mPbaName);
        strError+=QObject::tr("\nattribute %1 is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS).arg(ORTOSKYXMLMATCHESFILE_TAG_BUNDLE_ADJUSTMENT_PARAMETERS_ATTRIBUTE_TARGET_ORIENTATION);
        return(false);
    }
    mTargetOrientation=targetOrientation;

    bool okToInt=false;
    bool okToDouble=false;
    QString strValue;
    int intValue;
    double dblValue;

    // Lectura del número de imágenes a usar
    QDomNodeList numberOfImagesToUseNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
    if(numberOfImagesToUseNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    if(numberOfImagesToUseNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    QDomNode numberOfImagesToUseNode=numberOfImagesToUseNodes.at(0);
    strValue=numberOfImagesToUseNode.toElement().text();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
        return(false);
    }
    if(strValue.compare(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_ALL,Qt::CaseInsensitive)==0)
        mNumberOfImagesToUse=-1;
    else
    {
        intValue=strValue.toInt(&okToInt);
        if(!okToInt)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer or All").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE);
            return(false);
        }
        if(intValue<ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_MIN_VALUE||intValue>(mImages.size()-1))
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                    .arg(strValue)
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE)
                    .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_IMAGES_TO_USE_MIN_VALUE))
                    .arg(mImages.size());
            return(false);
        }
        mNumberOfImagesToUse=intValue;
    }

    // Lectura de la orientacion origen
    QDomNodeList sourceOrientationNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
    if(sourceOrientationNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
        return(false);
    }
    if(sourceOrientationNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %s node").arg(ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION);
        return(false);
    }
    QDomNode sourceOrientationNode=sourceOrientationNodes.at(0);
    strValue=sourceOrientationNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strValue=ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION_NO_INPUT;
    }
    mSourceOrientation=strValue;
    mSourceCalibration=ORTOSKYXMLMATCHESFILE_TAG_SOURCE_ORIENTATION_NO_INPUT; // lo leeré despúes
    // Comprobación de que existe?

    // Lectura del modelo de calibración
    QDomNodeList calibrationModelNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL);
    if(calibrationModelNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL);
        return(false);
    }
    if(calibrationModelNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL);
        return(false);
    }
    QDomNode calibrationModelNode=calibrationModelNodes.at(0);
    QDomElement calibrationModelElement=calibrationModelNode.toElement();
    strValue=calibrationModelElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ATTRIBUTE_TYPE).trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nFot tag: %1 id attribute %2 is empty")
            .arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL)
            .arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ATTRIBUTE_TYPE);
        return(false);
    }
    if(!mPBACalibrationModels.contains(strValue))
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid calibration model type: %1").arg(strValue);
        return(false);
    }
    mCalibrationModelId=strValue;
    mPBACalibrationModel=mPBACalibrationModels[strValue];
    mTapasDistModel = mPBACalibrationModel->getAperoId();
    mIsDGAPEngine=false;
    mPBAEngine=PBA_COMPUTATIONS_ENGINE_APERO;
    mPrintTiePointsAccuracies=false;
    if(mPBACalibrationModel->getIsSDGAP())
    {
        mPBAEngine=PBA_COMPUTATIONS_ENGINE_SDGAP;
        mIsDGAPEngine=true;
    }
    else
        mPBAEngine=PBA_COMPUTATIONS_ENGINE_APERO;
    if(mIsDGAPEngine)
    {
        if(mTapasDistModel.compare(APERO_CALIBRATION_MODEL_FRASER_BASIC)!=0)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nCalibration model: %1 is not valid for engine: %2").arg(mTapasDistModel).arg(mPBAEngine);
            return(false);
        }
    }
    if(mNumberOfImagesToUse!=-1) // no todas
    {
        if(mIsDGAPEngine)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError=QObject::tr("\nInvalid option: SDAG and a subset of images");
            return(false);
        }
    }
    if(mPBACalibrationModel->getIsFixed())
    {
        mCalibrationIsFixed=true;
        mTargetCalibration=ORTOSKYXMLMATCHESFILE_TAG_TARGET_CALIBRATION_NO_INPUT;
    }
    else
    {
        mCalibrationIsFixed=false;
        QString strTargetCalibration=calibrationModelElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ATTRIBUTE_TARGET_CALIBRATION).trimmed();
        if(strValue.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nFot tag: %1 id attribute %2 is empty")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION_MODEL_ATTRIBUTE_TARGET_CALIBRATION);
            return(false);
        }
        mTargetCalibration=strTargetCalibration;
    }

    mCreatePly=false;

    // Lectura de usar ground control
    QDomNodeList useGroundControlNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
    if(useGroundControlNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    if(useGroundControlNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %s node").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    QDomNode useGroundControlNode=useGroundControlNodes.at(0);
    strValue=useGroundControlNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%d,%d]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_USE_GROUND_CONTROL)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==0)
        mUseGroundControl=false;
    else
        mUseGroundControl=true;

    // Lectura de parámetros para la selección automática de TiePoints
    QDomNodeList parametersForAutomaticSelectionOfTiePointsNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
    if(parametersForAutomaticSelectionOfTiePointsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
        return(false);
    }
    if(parametersForAutomaticSelectionOfTiePointsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PARAMETERS_FOR_AUTOMATIC_SELECTION_OF_TIEPOINTS);
        return(false);
    }
    QDomElement parametersForAutomaticSelectionOfTiePointsNode=parametersForAutomaticSelectionOfTiePointsNodes.at(0).toElement();
    QDomNodeList standardDeviationThresholdNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
    if(standardDeviationThresholdNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    if(standardDeviationThresholdNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    QDomNode standardDeviationThresholdNode=standardDeviationThresholdNodes.at(0);
    strValue=standardDeviationThresholdNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    dblValue=strValue.toDouble(&okToDouble);
    if(!okToDouble)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not a double").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD);
        return(false);
    }
    if(dblValue<ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MIN_VALUE
            ||dblValue>ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MIN_VALUE,'f',2))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_STANDARD_DEVIATION_THRESHOLD_MAX_VALUE,'f',2));
        return(false);
    }
    mStandardDesviationThreshold=dblValue;
    QDomNodeList ccdGridSizeNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
    if(ccdGridSizeNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    if(ccdGridSizeNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    QDomNode ccdGridSizeNode=ccdGridSizeNodes.at(0);
    strValue=ccdGridSizeNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE);
        return(false);
    }
    QStringList strValues=strValue.split(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR);
    if(strValues.size()!=2)
    {
        strValues=strValue.split(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR_BIS);
        if(strValues.size()!=2)
        {
            strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nTag: %1 dont have to strings separated by %2")
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                    .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_SEPARATOR);
            return(false);
        }
    }
    intValue=strValues.at(0).toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                .arg(strValues.at(0));
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(0))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE));
        return(false);
    }
    mColumnsCcdGridSize=intValue;
    intValue=strValues.at(1).toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE)
                .arg(strValues.at(1));
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(1))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_CCD_GRID_SIZE_MAX_VALUE));
        return(false);
    }
    mRowsCcdGridSize=intValue;
    if(mColumnsCcdGridSize!=mRowsCcdGridSize)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nAt this state of development columns and rows in CCD grid must be equal");
        return(false);
    }
    QDomNodeList numberOfTiePointsInEachImageNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
    if(numberOfTiePointsInEachImageNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    if(numberOfTiePointsInEachImageNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    QDomNode numberOfTiePointsInEachImageNode=numberOfTiePointsInEachImageNodes.at(0);
    strValue=numberOfTiePointsInEachImageNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE)
                .arg(strValue);
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_NUMBER_OF_TIE_POINTS_IN_EACH_IMAGE_MAX_VALUE));
        return(false);
    }
    mNumberOfTiePointsInEachImage=intValue;
    QDomNodeList printTiePointsAccuraciesNodes=parametersForAutomaticSelectionOfTiePointsNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
    if(printTiePointsAccuraciesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    if(printTiePointsAccuraciesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    QDomNode printTiePointsAccuraciesNode=printTiePointsAccuraciesNodes.at(0);
    strValue=printTiePointsAccuraciesNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS)
                .arg(strValue);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRINT_ACCURACIES_OF_TIE_POINTS)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==1)
        mPrintTiePointsAccuracies=true;
    else
        mPrintTiePointsAccuracies=false;

    // Lectura de parámetros para mínimos cuadrados
    QDomNodeList leastSquaresParametersNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
    if(leastSquaresParametersNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
        return(false);
    }
    if(leastSquaresParametersNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_LEAST_SQUARES_PARAMETERS);
        return(false);
    }
    QDomElement leastSquaresParametersNode=leastSquaresParametersNodes.at(0).toElement();
    QDomNodeList prioriStandardDeviationOfUnitWeightNodes=leastSquaresParametersNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
    if(prioriStandardDeviationOfUnitWeightNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    if(prioriStandardDeviationOfUnitWeightNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    QDomNode prioriStandardDeviationOfUnitWeightNode=prioriStandardDeviationOfUnitWeightNodes.at(0);
    strValue=prioriStandardDeviationOfUnitWeightNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    dblValue=strValue.toDouble(&okToDouble);
    if(!okToDouble)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not a double").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT);
        return(false);
    }
    if(dblValue<ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MIN_VALUE
            ||dblValue>ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MIN_VALUE,'f',2))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_PRIORI_STANDART_DEVIATION_OF_UNIT_WEIGHT_MAX_VALUE,'f',2));
        return(false);
    }
    mPrioriStandardDeviationOfUnitWeight=dblValue*mXPixelSize_mm/1000.0;
    QDomNodeList maximumNumberOfIterationsNodes=leastSquaresParametersNode.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
    if(maximumNumberOfIterationsNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    if(maximumNumberOfIterationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    QDomNode maximumNumberOfIterationsNode=maximumNumberOfIterationsNodes.at(0);
    strValue=maximumNumberOfIterationsNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 value %2 is not an integer")
                .arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS)
                .arg(strValue);
        return(false);
    }
    if(intValue<ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MIN_VALUE||intValue>ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MAX_VALUE)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValues.at(1))
                .arg(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS)
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MIN_VALUE))
                .arg(QString::number(ORTOSKYXMLMATCHESFILE_TAG_MAXIMUM_NUMBER_OF_ITERATIONS_MAX_VALUE));
        return(false);
    }
    mMaximumNumberOfIterations=intValue;

    // Lectura del fichero de resultados
    /*
    QDomNodeList resultsFileNameNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
    if(resultsFileNameNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
        return(false);
    }
    if(resultsFileNameNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_RESULTS_FILE_NAME);
        return(false);
    }
    QDomNode resultsFileNameNode=resultsFileNameNodes.at(0);
    strValue=resultsFileNameNode.toElement().text().trimmed();
    mResultsFileName=mTmpFolder+"/"+strValue;
    */
    QString resultsBaseName=ORTOSKYXMLMATCHESFILE_RESULTS_FILE_NAME_BASE;
    QDateTime currentDateTime=QDateTime::currentDateTime();
    QString strCurrentDateTime=currentDateTime.toString("yyyy-MM-dd_hh-mm-ss");
    resultsBaseName+=strCurrentDateTime;
    resultsBaseName+=ORTOSKYXMLMATCHESFILE_RESULTS_FILE_NAME_EXTENSION;
    mResultsFileName=mTmpFolder+"/"+resultsBaseName;

    // Lectura de actualizar precisiones
    QDomNodeList updateAccuraciesNodes=bundleAdjustmentParametersElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
    if(updateAccuraciesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag %1 in the file").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    if(updateAccuraciesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one %1 node").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    QDomNode updateAccuraciesNode=updateAccuraciesNodes.at(0);
    strValue=updateAccuraciesNode.toElement().text().trimmed();
    if(strValue.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nTag: %1 id is empty").arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    intValue=strValue.toInt(&okToInt);
    if(!okToInt)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 is not an integer").arg(strValue).arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES);
        return(false);
    }
    if(intValue<0||intValue>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nvalue %1 in tag %2 out of domain [%3,%4]")
                .arg(strValue)
                .arg(ORTOSKYXMLMATCHESFILE_TAG_UPDATE_ACCURACIES)
                .arg(QString::number(0))
                .arg(QString::number(1));
        return(false);
    }
    if(intValue==0)
        mUpdateAccuracies=false;
    else
        mUpdateAccuracies=true;

    if(mUseGroundControl&&mNumberOfImagesToUse!=-1)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: ground control and number of images different to 'All'");
        return(false);
    }
    if(mUseGroundControl&&mSourceOrientation.isEmpty())
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: ground control without input calibration");
        return(false);
    }
    if(mIsDGAPEngine&&!mUseGroundControl)
    {
        strError=QObject::tr("OrientationProcessMonitor::setBundleAdjustmentParametersFromOrtoSkyXmlProjectFile\n, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nInvalid option: SDAG without ground control");
        return(false);
    }

    return(true);
}

bool OrientationProcessMonitor::solveInitialImagesProblem(QString &strError)
{
    // Comprobar y resolver el problema de que alguna de las imagenes conectadas no sea origen de matches
    // Este problema se ha detectado en apero
    bool findProblem=false;
    QVector<QString> noFirstImages;
    for(int nI=0;nI<mImages.size();nI++)
    {
        QString image=mImages[nI]->getFileName();
        if(!mImagesIdsTiePoints.contains(image))
        {
            findProblem=true;
            noFirstImages.push_back(image);
        }
    }
    if(findProblem)
    {
        bool control=true;
        while(noFirstImages.size()>0
              &&control)
        {
            QString noFirstImage=noFirstImages[0]; // porque las voy eliminando en la función que corrige
            control=convertInFirstImage(noFirstImage,noFirstImages,mImagesIdsTiePoints);
        }
    }
    return(true);
}

bool OrientationProcessMonitor::solveInitialImagesProblemOrtoSky(QString &strError)
{
    // Comprobar y resolver el problema de que alguna de las imagenes conectadas no sea origen de matches
    // Este problema se ha detectado en apero
    bool findProblem=false;
    QVector<QString> noFirstImages;
    for(int nI=0;nI<mImageNames.size();nI++)
    {
        QString imageId=mImageNames.at(nI);
        if(!mImagesIdsTiePoints.contains(imageId))
        {
            findProblem=true;
            noFirstImages.push_back(imageId);
        }
    }
    if(findProblem)
    {
        bool control=true;
        while(noFirstImages.size()>0
              &&control)
        {
            QString noFirstImage=noFirstImages[0]; // porque las voy eliminando en la función que corrige
            control=convertInFirstImage(noFirstImage,noFirstImages,mImagesIdsTiePoints);
        }
    }
    return(true);
}

bool OrientationProcessMonitor::writeAperoParamsFileOrtoSkyXml(QString calibrationModel,
                                                               QString inputRegExp,
                                                               QString inputCalibrationId,
                                                               QString micmacPath,
                                                               QString &aperoParamsFileName,
                                                               QString &strError)
{
//    if (calibrationModel == "RadialBasic")
//        aperoParamsFile = ":/PW/MICMAC/AperoRadialBasicGC";
//    else if (calibrationModel == "RadialExtended")
//        aperoParamsFile = ":/PW/MICMAC/AperoRadialExtendedGC";
//    else if (calibrationModel == "Fraser")
//        aperoParamsFile = ":/PW/MICMAC/AperoFraserGC";
//    else if (calibrationModel == "FraserBasic")
//        aperoParamsFile = ":/PW/MICMAC/AperoFraserBasicGC";

    QString aperoBaseFileName;
    if (calibrationModel == APERO_CALIBRATION_MODEL_FRASER_BASIC)
        aperoBaseFileName = micmacPath+"/"+ORIENTATIONPROCESSMONITOR_APERO_PARAMS_FILE_FRASER_BASIC;
    else
    {
        strError=QObject::tr("Invalid calibration model: %1").arg(calibrationModel);
        return(false);
    }
    if(!QFile::exists(aperoBaseFileName))
    {
        strError=QObject::tr("Not found apero template params file %1").arg(aperoBaseFileName);
        return(false);
    }
//    aperoParamsFileName=mImagesPath+"/Apero.xml";
    aperoParamsFileName=mTmpFolder+"/Apero.xml";
    if(QFile::exists(aperoParamsFileName))
    {
        if(!QFile::remove(aperoParamsFileName))
        {
            strError=QObject::tr("Error removing file %1").arg(aperoParamsFileName);
            return(false);
        }
    }
    if(!QFile::copy(aperoBaseFileName,aperoParamsFileName))
    {
        strError=QObject::tr("Error copying apero base file to file %1").arg(aperoParamsFileName);
        return(false);
    }
    //QFile aperoBaseFile(aperoBaseFileName);
    QFile aperoParamsFile(aperoParamsFileName);
    if(!aperoParamsFile.open(QIODevice::ReadOnly))
    {
        strError=QObject::tr("Error opening apero file for writting: %1").arg(aperoParamsFileName);
        return(false);
    }
    QString baseString(aperoParamsFile.readAll());
    aperoParamsFile.close();
    baseString.replace(QRegExp("PW_INPUT_IMGS"),inputRegExp);
    QString inputOri = inputCalibrationId;
    QString outputOri = calibrationModel;
//    QDir baseDir(mImagesPath+"/Ori-" + inputOri);
    QDir baseDir(mTmpFolder+"/Ori-" + inputOri);
    QStringList files = baseDir.entryList(QStringList("AutoCal*.xml"), QDir::Files | QDir::NoSymLinks);
    if (!files.isEmpty())
    {
        baseString.replace(QRegExp("PW_AUTOCAL_FILE"),files.at(0));
    }
    baseString.replace(QRegExp("PW_INPUT_ORI"),inputOri);
//    replace(&aperoParamsFile, &aperoParamsFile,"PW_INPUT_ORI", inputOri);

    baseString.replace(QRegExp("PW_OUTPUT_ORI"),outputOri);
//    replace(&aperoParamsFile, &aperoParamsFile,"PW_OUTPUT_ORI",outputOri);

    baseString.replace(QRegExp("PW_MATCH_FORMAT"),"txt");
//    replace(&aperoParamsFile, &aperoParamsFile,"PW_MATCH_FORMAT","txt");

    baseString.replace(QRegExp("Pastis_SigmaPond_E1"),LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_0_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_SigmaPond_E1",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_0_VALUE);

    baseString.replace(QRegExp("Pastis_SigmaPond_E2"),LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_SigmaPond_E2",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_1_VALUE);

    baseString.replace(QRegExp("Pastis_EcartMax_E1"),LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_0_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMax_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_0_VALUE);

    baseString.replace(QRegExp("Pastis_EcartMax_E2"),LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMax_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_1_VALUE);

    baseString.replace(QRegExp("Appui_SigmaPond_E1"),LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_0_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_SigmaPond_E1",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_0_VALUE);

    baseString.replace(QRegExp("Appui_SigmaPond_E2"),LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_SigmaPond_E2",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_1_VALUE);

    baseString.replace(QRegExp("Appui_EcartMax_E1"),LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_0_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMax_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_0_VALUE);

    baseString.replace(QRegExp("Appui_EcartMax_E2"),LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMax_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_1_VALUE);

    baseString.replace(QRegExp("Pastis_EcartMesureIndiv_E1"),LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_0_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMesureIndiv_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_0_VALUE);

    baseString.replace(QRegExp("Pastis_EcartMesureIndiv_E2"),LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMesureIndiv_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_1_VALUE);

    baseString.replace(QRegExp("Appui_EcartMesureIndiv_E1"),LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMesureIndiv_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);

    baseString.replace(QRegExp("Appui_EcartMesureIndiv_E2"),LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);
//    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMesureIndiv_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);

    if(!aperoParamsFile.open(QIODevice::WriteOnly))
    {
        strError=QObject::tr("Error opening apero file for writting: %1").arg(aperoParamsFileName);
        return(false);
    }
    QTextStream outputStream(&aperoParamsFile);
    outputStream << baseString << "\n";
    aperoParamsFile.close();

    //aperoBaseFileName.close(); // no hace falta porque lo hace la función replace

    /*
    // Para poner los parámetros de ponderación
    // Supongo dos etapas de compensación
    QFile newAperoParamsFile(aperoParamsFileName);
    if (!newAperoParamsFile.open(QFile::ReadOnly | QFile::Text))
    {
        strError=QObject::tr("Error opening file:\n%1").arg(aperoParamsFileName);
        return(false);
    }
    QString errorStr;
    QString noStr;
    int errorLine;
    int errorColumn;
    QDomDocument aperoDoc;
    if (!aperoDoc.setContent(&newAperoParamsFile,true,&errorStr,&errorLine,&errorColumn))
    {
        strError=QObject::tr("Error reading file:\n%1").arg(aperoParamsFileName);
        strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
        return(false);
    }
    newAperoParamsFile.close();

    QDomNodeList etapesCompensationNodes=aperoDoc.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION);
    if(etapesCompensationNodes.size()==0)
    {
        strError+=QObject::tr("No tag %1 in the file %2")
                .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION)
                .arg(aperoParamsFileName);
        return(false);
    }
//    if(etapesCompensationNodes.size()>1)
//    {
//        strError+=QObject::tr("\nThere are more than one %1 node in file %2")
//                .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION)
//                .arg(aperoParamsFileName);
//        return(false);
//    }
    for(int nec=0;nec<etapesCompensationNodes.size();nec++)
    {
        QDomNode etapeCompensationNode=etapesCompensationNodes.at(nec);
        QDomElement etapeCompensationElement=etapeCompensationNode.toElement();

        // Ponderación de los matches
        QDomNodeList obsMatchesNodes=etapeCompensationElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS);
        if(obsMatchesNodes.size()==0)
        {
            strError+=QObject::tr("No tag %1 in compensation stage %2 the file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        if(obsMatchesNodes.size()>1)
        {
            strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        QDomNode obsMatchesNode=obsMatchesNodes.at(0);
        QDomElement obsMatchesElement=obsMatchesNode.toElement();
        {
            QDomNodeList nbMaxNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX);
            if(nbMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(nbMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode nbMaxNode=nbMaxNodes.at(0);
            if(nec==0)
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_MATCHES_STAGE_0_VALUE);
            else
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_MATCHES_STAGE_1_VALUE);

            QDomNodeList sigmaPondNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND);
            if(sigmaPondNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(sigmaPondNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode sigmaPondNode=sigmaPondNodes.at(0);
            if(nec==0)
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_0_VALUE);
            else
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_1_VALUE);

            QDomNodeList ecartMaxNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX);
            if(ecartMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(ecartMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode ecartMaxNode=ecartMaxNodes.at(0);
            if(nec==0)
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_0_VALUE);
            else
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_1_VALUE);
            obsMatchesNode.replaceChild(ecartMaxNode,ecartMaxNode);
        }
        etapeCompensationNode.replaceChild(obsMatchesNode,obsMatchesNode);

        // Ponderación de los puntos de apoyo
        QDomNodeList obsGCPsNodes=etapeCompensationElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT);
        if(obsGCPsNodes.size()==0)
        {
            strError+=QObject::tr("No tag %1 in compensation stage %2 the file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        if(obsGCPsNodes.size()>1)
        {
            strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        QDomNode obsGCPsNode=obsGCPsNodes.at(0);
        QDomElement obsGCPsElement=obsGCPsNode.toElement();
        {
            QDomNodeList nbMaxNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX);
            if(nbMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(nbMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode nbMaxNode=nbMaxNodes.at(0);
            if(nec==0)
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_GCPS_STAGE_0_VALUE);
            else
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_GCPS_STAGE_1_VALUE);

            QDomNodeList sigmaPondNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND);
            if(sigmaPondNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(sigmaPondNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode sigmaPondNode=sigmaPondNodes.at(0);
            if(nec==0)
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_0_VALUE);
            else
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_1_VALUE);

            QDomNodeList ecartMaxNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX);
            if(ecartMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(ecartMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode ecartMaxNode=ecartMaxNodes.at(0);
            if(nec==0)
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_0_VALUE);
            else
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_1_VALUE);
        }
        aperoDoc.replaceChild(etapeCompensationNode,etapeCompensationNode);
    }
    const int IndentSize = 4;
    if (!newAperoParamsFile.open(QFile::WriteOnly | QFile::Text))
    {
        strError=QObject::tr("Error opening file:\n%1").arg(aperoParamsFileName);
        return(false);
    }
    QTextStream out(&newAperoParamsFile);
    aperoDoc.save(out, IndentSize);
    newAperoParamsFile.close();

//        QList<QParams::Param *> params = getOrientationsDialog()->getAdvancedParams().values();
//        for(int i=0; i< params.count(); i++){
//            QParams::ContinuousParam *param = dynamic_cast<QParams::ContinuousParam*>(params.at(i));
//            replace(&AperoParamsFile, &AperoParamsFile,param->getName(),
//                    QString::number(param->getValue()));
//        }
*/
    return(true);
}

bool OrientationProcessMonitor::updateTiePointsAccuracySDGAP(QString& strError)
{
    mMatchesAccuracies.clear();
    mAccuraciesByMatchId.clear();
    mMatchesTerrainCoordinates.clear();
    mMatchesAccuraciesTerrainCoordinates.clear();
    QMap<QString, QMap<QString, QVector<int> > >::const_iterator iter=mMatchesIds.begin();
    while(iter!=mMatchesIds.end())
    {
        QString firstImageId=iter.key();
        //PW::PWImage* firstImage=this->getImageByName(firstImageId);
        if(!mImagesByName.contains(firstImageId))
        {
            strError=QObject::tr("OrientationProcessMonitor:: image id: %1 not found").arg(firstImageId);
        }
        PW::PWImage* firstImage=mImagesByName[firstImageId];
        int firstImageWidth=firstImage->getSize().width();
        int firstImageHeight=firstImage->getSize().height();
        PW::PhotogrammetricModel *pm1=(PhotogrammetricModel *)firstImage->getCamera()->getCameraModel();
        PW::Camera *firstCamera = firstImage->getCamera();
        double firstImageSensorWidth_mm=firstCamera->getSensorWidth();
        double firstImageSensorHeight_mm=firstCamera->getSensorHeight();
        double firstImageXPixelSize_mm=firstImageSensorWidth_mm/((double)firstImageWidth); // en mm
        double firstImageYPixelSize_mm=firstImageSensorHeight_mm/((double)firstImageHeight); // en mm
        double firstImageXPixelSize_mc=firstImageXPixelSize_mm*1e-3;
        double firstImageYPixelSize_mc=firstImageYPixelSize_mm*1e-3;
        double firstImageFocal_pixel=pm1->getFocal();
        double firstImageFocal_mm=firstImageFocal_pixel*firstImageXPixelSize_mm;
//        double firstImageFocal_m=firstImageFocal_mm*1e-3;
        double firstImageXPPA_ul_pixel=pm1->getXp();
        double firstImageYPPA_ul_pixel=pm1->getYp();
//        double firstImageXPPAFromCenter_mm=(firstImageXPPA_ul_pixel-((double)firstImageWidth)/2.0)*firstImageXPixelSize_mm;
//        double firstImageYPPAFromCenter_mm=(((double)firstImageHeight)/2.0-firstImageYPPA_ul_pixel)*firstImageXPixelSize_mm;
//        double xPPAFromCenter_m=xPPAFromCenter_mm*1e-3;
//        double yPPAFromCenter_m=yPPAFromCenter_mm*1e-3;
        double firstImageXPPAFromCenter_m=(firstImageXPPA_ul_pixel-((double)firstImageWidth)/2.0)*firstImageXPixelSize_mc;
        double firstImageYPPAFromCenter_m=-(firstImageYPPA_ul_pixel - ((double)firstImageHeight)/2.0)*firstImageYPixelSize_mc;
        double firstImageFocal_m=firstImageFocal_pixel*firstImageXPixelSize_mc;
        double firstImage_diff_focal_m=0.0;
        double firstImage_diff_xPPA_m=0.0;
        double firstImage_diff_yPPA_m=0.0;
        PW::DistortionModel* firstImageDistortionModel=pm1->getDistortionModel();
        double firstImageK1_pixel=((FraserModel*)firstImageDistortionModel)->getK1();
        double firstImageK2_pixel=((FraserModel*)firstImageDistortionModel)->getK2();
        double firstImageK3_pixel=((FraserModel*)firstImageDistortionModel)->getK3();
        double firstImageP1_pixel=((FraserModel*)firstImageDistortionModel)->getP1();
        double firstImageP2_pixel=((FraserModel*)firstImageDistortionModel)->getP2();
        double firstImageB1_pixel=((FraserModel*)firstImageDistortionModel)->getB1();
        double firstImageB2_pixel=((FraserModel*)firstImageDistortionModel)->getB2();
        double firstImageK1=firstImageK1_pixel/pow(firstImageXPixelSize_mm,2.0)/pow(firstImageXPixelSize_mm,2.0);
        double firstImageK2=firstImageK2_pixel/pow(firstImageXPixelSize_mm,4.0)/pow(firstImageXPixelSize_mm,4.0);
        double firstImageK3=firstImageK3_pixel/pow(firstImageXPixelSize_mm,6.0)/pow(firstImageXPixelSize_mm,6.0);
        double firstImageP1=firstImageP1_pixel/firstImageXPixelSize_mm/firstImageXPixelSize_mm;
        double firstImageP2=firstImageP2_pixel/firstImageXPixelSize_mm/firstImageXPixelSize_mm;
        double firstImageB1=firstImageB1_pixel;//xPixelSize_mm;
        double firstImageB2=firstImageB2_pixel;//xPixelSize_mm;
        QVector< QVector<double> > * r1 = firstImage->getExteriorOrientation()->getR();
        QVector<double> * cp1 = firstImage->getExteriorOrientation()->getCP();
        double firstImageXL=(*cp1)[0]; // coordenadas del centro de proyección de la imagen
        double firstImageYL=(*cp1)[1];
        double firstImageZL=(*cp1)[2];
        double firstImageR11=(*r1)[0][0]; // matriz de rotación
        double firstImageR12=-1.0*(*r1)[0][1];
        double firstImageR13=-1.0*(*r1)[0][2];
        double firstImageR21=(*r1)[1][0];
        double firstImageR22=-1.0*(*r1)[1][1];
        double firstImageR23=-1.0*(*r1)[1][2];
        double firstImageR31=(*r1)[2][0];
        double firstImageR32=-1.0*(*r1)[2][1];
        double firstImageR33=-1.0*(*r1)[2][2];
        QMap<QString, QVector<int> > matchesIdsByFirstImage=iter.value();
        QMap<QString, QVector<int> >::const_iterator iterBis=matchesIdsByFirstImage.begin();
        QMap<QString, QVector<float> > matchesAccuraciesByFirstImage;
        while(iterBis!=matchesIdsByFirstImage.end())
        {
            QString secondImageId=iterBis.key();
            if(!mImagesByName.contains(secondImageId))
            {
                strError=QObject::tr("OrientationProcessMonitor:: image id: %1 not found").arg(secondImageId);
            }
            PW::PWImage* secondImage=mImagesByName[secondImageId];
            int secondImageWidth=secondImage->getSize().width();
            int secondImageHeight=secondImage->getSize().height();
            PW::PhotogrammetricModel *pm2=(PhotogrammetricModel *)secondImage->getCamera()->getCameraModel();
            PW::Camera *secondCamera = secondImage->getCamera();
            double secondImageSensorWidth_mm=secondCamera->getSensorWidth();
            double secondImageSensorHeight_mm=secondCamera->getSensorHeight();
            double secondImageXPixelSize_mm=secondImageSensorWidth_mm/((double)secondImageWidth); // en mm
            double secondImageYPixelSize_mm=secondImageSensorHeight_mm/((double)secondImageHeight); // en mm
            double secondImageXPixelSize_mc=secondImageXPixelSize_mm*1e-3;
            double secondImageYPixelSize_mc=secondImageYPixelSize_mm*1e-3;
            double secondImageFocal_pixel=pm2->getFocal();
            double secondImageFocal_mm=secondImageFocal_pixel*secondImageXPixelSize_mm;
    //        double firstImageFocal_m=firstImageFocal_mm*1e-3;
            double secondImageXPPA_ul_pixel=pm2->getXp();
            double secondImageYPPA_ul_pixel=pm2->getYp();
    //        double firstImageXPPAFromCenter_mm=(firstImageXPPA_ul_pixel-((double)firstImageWidth)/2.0)*firstImageXPixelSize_mm;
    //        double firstImageYPPAFromCenter_mm=(((double)firstImageHeight)/2.0-firstImageYPPA_ul_pixel)*firstImageXPixelSize_mm;
    //        double xPPAFromCenter_m=xPPAFromCenter_mm*1e-3;
    //        double yPPAFromCenter_m=yPPAFromCenter_mm*1e-3;
            double secondImageXPPAFromCenter_m=(secondImageXPPA_ul_pixel-((double)secondImageWidth)/2.0)*secondImageXPixelSize_mc;
            double secondImageYPPAFromCenter_m=-(secondImageYPPA_ul_pixel - ((double)secondImageHeight)/2.0)*secondImageYPixelSize_mc;
            double secondImageFocal_m=secondImageFocal_pixel*secondImageXPixelSize_mc;
            double secondImage_diff_focal_m=0.0;
            double secondImage_diff_xPPA_m=0.0;
            double secondImage_diff_yPPA_m=0.0;
            PW::DistortionModel* secondImageDistortionModel=pm1->getDistortionModel();
            double secondImageK1_pixel=((FraserModel*)secondImageDistortionModel)->getK1();
            double secondImageK2_pixel=((FraserModel*)secondImageDistortionModel)->getK2();
            double secondImageK3_pixel=((FraserModel*)secondImageDistortionModel)->getK3();
            double secondImageP1_pixel=((FraserModel*)secondImageDistortionModel)->getP1();
            double secondImageP2_pixel=((FraserModel*)secondImageDistortionModel)->getP2();
            double secondImageB1_pixel=((FraserModel*)secondImageDistortionModel)->getB1();
            double secondImageB2_pixel=((FraserModel*)secondImageDistortionModel)->getB2();
            double secondImageK1=secondImageK1_pixel/pow(secondImageXPixelSize_mm,2.0)/pow(secondImageXPixelSize_mm,2.0);
            double secondImageK2=secondImageK2_pixel/pow(secondImageXPixelSize_mm,4.0)/pow(secondImageXPixelSize_mm,4.0);
            double secondImageK3=secondImageK3_pixel/pow(secondImageXPixelSize_mm,6.0)/pow(secondImageXPixelSize_mm,6.0);
            double secondImageP1=secondImageP1_pixel/secondImageXPixelSize_mm/secondImageXPixelSize_mm;
            double secondImageP2=secondImageP2_pixel/secondImageXPixelSize_mm/secondImageXPixelSize_mm;
            double secondImageB1=secondImageB1_pixel;//xPixelSize_mm;
            double secondImageB2=secondImageB2_pixel;//xPixelSize_mm;
            QVector< QVector<double> > * r2 = secondImage->getExteriorOrientation()->getR();
            QVector<double> * cp2 = secondImage->getExteriorOrientation()->getCP();
            double secondImageXL=(*cp2)[0]; // coordenadas del centro de proyección de la imagen
            double secondImageYL=(*cp2)[1];
            double secondImageZL=(*cp2)[2];
            double secondImageR11=(*r2)[0][0]; // matriz de rotación
            double secondImageR12=-1.0*(*r2)[0][1];
            double secondImageR13=-1.0*(*r2)[0][2];
            double secondImageR21=(*r2)[1][0];
            double secondImageR22=-1.0*(*r2)[1][1];
            double secondImageR23=-1.0*(*r2)[1][2];
            double secondImageR31=(*r2)[2][0];
            double secondImageR32=-1.0*(*r2)[2][1];
            double secondImageR33=-1.0*(*r2)[2][2];
            QVector<int> matchesIds=iterBis.value();
            QVector<float> firstImageColumns=mImagesFirstColumnsTiePoints[firstImageId][secondImageId];
            QVector<float> firstImageRows=mImagesFirstRowsTiePoints[firstImageId][secondImageId];
            QVector<float> secondImageColumns=mImagesSecondColumnsTiePoints[firstImageId][secondImageId];
            QVector<float> secondImageRows=mImagesSecondRowsTiePoints[firstImageId][secondImageId];
            QVector<float> accuracies;
            for(int nM=0;nM<matchesIds.size();nM++)
            {
                int matchId=matchesIds[nM];
                float x1=firstImageColumns[nM];
                float y1=firstImageRows[nM];
                float x2=secondImageColumns[nM];
                float y2=secondImageRows[nM];
                float accuracy=0.0;

                // 1. Paso de coordenadas sensor (CCD) a imagen (respecto al centro físico, en mm y con la y invertida)
                double img_c_x_1=x1;
                double img_c_y_1=y1;
                sensor_to_image_sdgap(firstImageWidth,firstImageHeight,
                                      firstImageXPixelSize_mc,firstImageYPixelSize_mc,
                                      img_c_x_1,img_c_y_1);
                double img_c_x_2=x2;
                double img_c_y_2=y2;
                sensor_to_image_sdgap(secondImageWidth,secondImageHeight,
                                      secondImageXPixelSize_mc,secondImageYPixelSize_mc,
                                      img_c_x_2,img_c_y_2);

                // 2. Paso a coordenadas Photo, referidas al PPA y con la focal
                double pho_c_x_1=img_c_x_1;
                double pho_c_y_1=img_c_y_1;
                double pho_c_z_1=0.0;
                image_to_photo_sdgap(firstImageFocal_m,
                                     firstImageXPPAFromCenter_m,firstImageYPPAFromCenter_m,
                                     pho_c_x_1,pho_c_y_1,pho_c_z_1);
                double pho_c_x_2=img_c_x_2;
                double pho_c_y_2=img_c_y_2;
                double pho_c_z_2=0.0;
                image_to_photo_sdgap(secondImageFocal_m,
                                     secondImageXPPAFromCenter_m,secondImageYPPAFromCenter_m,
                                     pho_c_x_2,pho_c_y_2,pho_c_z_2);

                // 3. Eliminación de la distorsión
                undistort_sdgap(firstImage_diff_xPPA_m,firstImage_diff_yPPA_m,firstImage_diff_focal_m,
                                firstImageK1,firstImageK2,firstImageK3,
                                firstImageP1,firstImageP2,
                                firstImageB1,firstImageB2,
                                pho_c_x_1,pho_c_y_1,pho_c_z_1);
                undistort_sdgap(secondImage_diff_xPPA_m,secondImage_diff_yPPA_m,secondImage_diff_focal_m,
                                secondImageK1,secondImageK2,secondImageK3,
                                secondImageP1,secondImageP2,
                                secondImageB1,secondImageB2,
                                pho_c_x_2,pho_c_y_2,pho_c_z_2);

                double xi_1=pho_c_x_1;
                double yi_1=pho_c_y_1;
                double focal_1=pho_c_z_1;
                double a_1=firstImageR11*xi_1+firstImageR12*yi_1+firstImageR13*focal_1;
                double d_1=firstImageR21*xi_1+firstImageR22*yi_1+firstImageR23*focal_1;
                double c_1=firstImageR31*xi_1+firstImageR32*yi_1+firstImageR33*focal_1;

                double xi_2=pho_c_x_2;
                double yi_2=pho_c_y_2;
                double focal_2=pho_c_z_2;
                double a_2=secondImageR11*xi_2+secondImageR12*yi_2+secondImageR13*focal_2;
                double d_2=secondImageR21*xi_2+secondImageR22*yi_2+secondImageR23*focal_2;
                double c_2=secondImageR31*xi_2+secondImageR32*yi_2+secondImageR33*focal_2;

                Eigen::MatrixXd A(4,3);
                Eigen::VectorXd b(4);
                A(0,0) = c_1;
                A(0,1) = 0.0;
                A(0,2) = -1.0*a_1;
                A(1,0) = 0.0;
                A(1,1) = c_1;
                A(1,2) = -1.0*d_1;
                b(0)=c_1*firstImageXL-a_1*firstImageZL;
                b(1)=c_1*firstImageYL-d_1*firstImageZL;
                A(2,0) = c_2;
                A(2,1) = 0.0;
                A(2,2) = -1.0*a_2;
                A(3,0) = 0.0;
                A(3,1) = c_2;
                A(3,2) = -1.0*d_2;
                b(2)=c_2*secondImageXL-a_2*secondImageZL;
                b(3)=c_2*secondImageYL-d_2*secondImageZL;

                Eigen::VectorXd sol=(A.transpose() * A).ldlt().solve(A.transpose() * b);
                Eigen::VectorXd residuals=A*sol-b;
                double res2d=sqrt(residuals(0)*residuals(0)+residuals(1)*residuals(1)+residuals(2)*residuals(2)+residuals(3)*residuals(3));
                Eigen::MatrixXd Qxx=(A.transpose() * A).inverse();
                double std_xT=Qxx(0,0);
                double std_yT=Qxx(1,1);
                double std_zT=Qxx(2,2);

                double xT=sol(0);
                double yT=sol(1);
                double zT=sol(2);

                // 1. Coordenadas photo
                double pho_c_z_b1= focal_1; //-1.0*focal_1; // porque ya está puesto a negativo
                double pho_c_x_b1 = pho_c_z_b1*(firstImageR11*(xT-firstImageXL)+firstImageR21*(yT-firstImageYL)+firstImageR31*(zT-firstImageZL))/(firstImageR13*(xT-firstImageXL)+firstImageR23*(yT-firstImageYL)+firstImageR33*(zT-firstImageZL));
                double pho_c_y_b1 = pho_c_z_b1*(firstImageR12*(xT-firstImageXL)+firstImageR22*(yT-firstImageYL)+firstImageR32*(zT-firstImageZL))/(firstImageR13*(xT-firstImageXL)+firstImageR23*(yT-firstImageYL)+firstImageR33*(zT-firstImageZL));
                double pho_c_z_b2= focal_2; //-1.0*focal_2; // porque ya está puesto a negativo
                double pho_c_x_b2 = pho_c_z_b2*(secondImageR11*(xT-secondImageXL)+secondImageR21*(yT-secondImageYL)+secondImageR31*(zT-secondImageZL))/(secondImageR13*(xT-secondImageXL)+secondImageR23*(yT-secondImageYL)+secondImageR33*(zT-secondImageZL));
                double pho_c_y_b2 = pho_c_z_b2*(secondImageR12*(xT-secondImageXL)+secondImageR22*(yT-secondImageYL)+secondImageR32*(zT-secondImageZL))/(secondImageR13*(xT-secondImageXL)+secondImageR23*(yT-secondImageYL)+secondImageR33*(zT-secondImageZL));

                // 2. Añadir la distorsión
                distort_sdgap(firstImage_diff_xPPA_m,firstImage_diff_yPPA_m,firstImage_diff_focal_m,
                              firstImageK1,firstImageK2,firstImageK3,
                              firstImageP1,firstImageP2,
                              firstImageB1,firstImageB2,
                              pho_c_x_b1,pho_c_y_b1,pho_c_z_b1);
                distort_sdgap(secondImage_diff_xPPA_m,secondImage_diff_yPPA_m,secondImage_diff_focal_m,
                              secondImageK1,secondImageK2,secondImageK3,
                              secondImageP1,secondImageP2,
                              secondImageB1,secondImageB2,
                              pho_c_x_b2,pho_c_y_b2,pho_c_z_b2);

                // 3. De photo a image
                double img_c_x_b1=pho_c_x_b1;
                double img_c_y_b1=pho_c_y_b1;
                photo_to_image_sdgap(firstImageXPPAFromCenter_m,firstImageYPPAFromCenter_m,
                                     img_c_x_b1,img_c_y_b1);
                double img_c_x_b2=pho_c_x_b2;
                double img_c_y_b2=pho_c_y_b2;
                photo_to_image_sdgap(secondImageXPPAFromCenter_m,secondImageYPPAFromCenter_m,
                                     img_c_x_b2,img_c_y_b2);

                // 4. De image a sensor
                double sen_c_x_b1=img_c_x_b1;
                double sen_c_y_b1=img_c_y_b1;
                image_to_sensor_sdgap(firstImageWidth,firstImageHeight,
                                      firstImageXPixelSize_mc,firstImageYPixelSize_mc,
                                      sen_c_x_b1,sen_c_y_b1);
                double sen_c_x_b2=img_c_x_b2;
                double sen_c_y_b2=img_c_y_b2;
                image_to_sensor_sdgap(secondImageWidth,secondImageHeight,
                                      secondImageXPixelSize_mc,secondImageYPixelSize_mc,
                                      sen_c_x_b2,sen_c_y_b2);

                double x1_error=firstImageColumns[nM]-sen_c_x_b1;
                double y1_error=firstImageRows[nM]-sen_c_y_b1;
                double x2_error=secondImageColumns[nM]-sen_c_x_b2;
                double y2_error=secondImageRows[nM]-sen_c_y_b2;
                accuracy=sqrt(x1_error*x1_error+y1_error*y1_error+x2_error*x2_error+y2_error*y2_error);
//                A=[c1   0  -a1
//                    0  c1  -d1
//                   c2   0  -a2
//                    0  c2  -d2];
//                b=[c1*XC1(1)-a1*XC1(3)
//                   c1*XC1(2)-d1*XC1(3)
//                   c2*XC2(1)-a2*XC2(3)
//                   c2*XC2(2)-d2*XC2(3)];
//                X=inv(A'*A)*(A'*b);
//                R=A*X-b;
//                xT=X(1);
//                yT=X(2);
//                zT=X(3);
                accuracies.push_back(accuracy);
                mAccuraciesByMatchId[matchId]=accuracy;
                QVector<float> terrainCoordinates(3);
                terrainCoordinates[0]=xT;
                terrainCoordinates[1]=yT;
                terrainCoordinates[2]=zT;
                mMatchesTerrainCoordinates[matchId]=terrainCoordinates;
                QVector<float> accuraciesTerrainCoordinates(3);
                accuraciesTerrainCoordinates[0]=std_xT;
                accuraciesTerrainCoordinates[1]=std_yT;
                accuraciesTerrainCoordinates[2]=std_zT;
                mMatchesAccuraciesTerrainCoordinates[matchId]=accuraciesTerrainCoordinates;
            }
            matchesAccuraciesByFirstImage[secondImageId]=accuracies;
            iterBis++;
        }
        mMatchesAccuracies[firstImageId]=matchesAccuraciesByFirstImage;
        iter++;
    }
    return(true);
}

bool OrientationProcessMonitor::writeAperoParamsFile(QString calibrationModel,
                                                     QString inputRegExp,
                                                     QString inputCalibrationId,
                                                     QString micmacPath,
                                                     QString &aperoParamsFileName,
                                                     QString &strError)
{
//    if (calibrationModel == "RadialBasic")
//        aperoParamsFile = ":/PW/MICMAC/AperoRadialBasicGC";
//    else if (calibrationModel == "RadialExtended")
//        aperoParamsFile = ":/PW/MICMAC/AperoRadialExtendedGC";
//    else if (calibrationModel == "Fraser")
//        aperoParamsFile = ":/PW/MICMAC/AperoFraserGC";
//    else if (calibrationModel == "FraserBasic")
//        aperoParamsFile = ":/PW/MICMAC/AperoFraserBasicGC";

    QString aperoBaseFileName;
    if (calibrationModel == APERO_CALIBRATION_MODEL_FRASER_BASIC)
        aperoBaseFileName = micmacPath+"/"+ORIENTATIONPROCESSMONITOR_APERO_PARAMS_FILE_FRASER_BASIC;
    else
    {
        strError=QObject::tr("Invalid calibration model: %1").arg(calibrationModel);
        return(false);
    }
    if(!QFile::exists(aperoBaseFileName))
    {
        strError=QObject::tr("Not found apero template params file %1").arg(aperoBaseFileName);
        return(false);
    }
//    aperoParamsFileName=mImagesPath+"/Apero.xml";
    aperoParamsFileName=mTmpFolder+"/Apero.xml";
    if(QFile::exists(aperoParamsFileName))
    {
        if(!QFile::remove(aperoParamsFileName))
        {
            strError=QObject::tr("Error removing file %1").arg(aperoParamsFileName);
            return(false);
        }
    }
    if(!QFile::copy(aperoBaseFileName,aperoParamsFileName))
    {
        strError=QObject::tr("Error copying apero base file to file %1").arg(aperoParamsFileName);
        return(false);
    }
    //QFile aperoBaseFile(aperoBaseFileName);
    QFile aperoParamsFile(aperoParamsFileName);
    replace(&aperoParamsFile, &aperoParamsFile,"PW_INPUT_IMGS",inputRegExp);
    QString inputOri = inputCalibrationId;
    QString outputOri = calibrationModel;
//    QDir baseDir(mImagesPath+"/Ori-" + inputOri);
    QDir baseDir(mTmpFolder+"/Ori-" + inputOri);
    QStringList files = baseDir.entryList(QStringList("AutoCal*.xml"), QDir::Files | QDir::NoSymLinks);
    if (!files.isEmpty())
        replace(&aperoParamsFile, &aperoParamsFile,"PW_AUTOCAL_FILE",files.at(0));
    replace(&aperoParamsFile, &aperoParamsFile,"PW_INPUT_ORI", inputOri);
    replace(&aperoParamsFile, &aperoParamsFile,"PW_OUTPUT_ORI",outputOri);
    replace(&aperoParamsFile, &aperoParamsFile,"PW_MATCH_FORMAT","txt");
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_SigmaPond_E1",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_0_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_SigmaPond_E2",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMax_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_0_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMax_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_SigmaPond_E1",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_0_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_SigmaPond_E2",LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMax_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_0_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMax_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMesureIndiv_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_0_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Pastis_EcartMesureIndiv_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_MATCHES_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMesureIndiv_E1",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);
    replace(&aperoParamsFile, &aperoParamsFile,"Appui_EcartMesureIndiv_E2",LIPPW_APERO_PARAMETERS_FILE_ECARTMESUREINDIV_GCPS_STAGE_1_VALUE);

    //aperoBaseFileName.close(); // no hace falta porque lo hace la función replace

    /*
    // Para poner los parámetros de ponderación
    // Supongo dos etapas de compensación
    QFile newAperoParamsFile(aperoParamsFileName);
    if (!newAperoParamsFile.open(QFile::ReadOnly | QFile::Text))
    {
        strError=QObject::tr("Error opening file:\n%1").arg(aperoParamsFileName);
        return(false);
    }
    QString errorStr;
    QString noStr;
    int errorLine;
    int errorColumn;
    QDomDocument aperoDoc;
    if (!aperoDoc.setContent(&newAperoParamsFile,true,&errorStr,&errorLine,&errorColumn))
    {
        strError=QObject::tr("Error reading file:\n%1").arg(aperoParamsFileName);
        strError+=QObject::tr("\nError: %1 in line %2 in column %3").arg(errorStr).arg(QString::number(errorLine)).arg(QString::number(errorColumn));
        return(false);
    }
    newAperoParamsFile.close();

    QDomNodeList etapesCompensationNodes=aperoDoc.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION);
    if(etapesCompensationNodes.size()==0)
    {
        strError+=QObject::tr("No tag %1 in the file %2")
                .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION)
                .arg(aperoParamsFileName);
        return(false);
    }
//    if(etapesCompensationNodes.size()>1)
//    {
//        strError+=QObject::tr("\nThere are more than one %1 node in file %2")
//                .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ETAPECOMPENSATION)
//                .arg(aperoParamsFileName);
//        return(false);
//    }
    for(int nec=0;nec<etapesCompensationNodes.size();nec++)
    {
        QDomNode etapeCompensationNode=etapesCompensationNodes.at(nec);
        QDomElement etapeCompensationElement=etapeCompensationNode.toElement();

        // Ponderación de los matches
        QDomNodeList obsMatchesNodes=etapeCompensationElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS);
        if(obsMatchesNodes.size()==0)
        {
            strError+=QObject::tr("No tag %1 in compensation stage %2 the file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        if(obsMatchesNodes.size()>1)
        {
            strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        QDomNode obsMatchesNode=obsMatchesNodes.at(0);
        QDomElement obsMatchesElement=obsMatchesNode.toElement();
        {
            QDomNodeList nbMaxNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX);
            if(nbMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(nbMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode nbMaxNode=nbMaxNodes.at(0);
            if(nec==0)
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_MATCHES_STAGE_0_VALUE);
            else
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_MATCHES_STAGE_1_VALUE);

            QDomNodeList sigmaPondNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND);
            if(sigmaPondNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(sigmaPondNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode sigmaPondNode=sigmaPondNodes.at(0);
            if(nec==0)
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_0_VALUE);
            else
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_MATCHES_STAGE_1_VALUE);

            QDomNodeList ecartMaxNodes=obsMatchesElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX);
            if(ecartMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(ecartMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSLIAISONS)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode ecartMaxNode=ecartMaxNodes.at(0);
            if(nec==0)
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_0_VALUE);
            else
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_MATCHES_STAGE_1_VALUE);
            obsMatchesNode.replaceChild(ecartMaxNode,ecartMaxNode);
        }
        etapeCompensationNode.replaceChild(obsMatchesNode,obsMatchesNode);

        // Ponderación de los puntos de apoyo
        QDomNodeList obsGCPsNodes=etapeCompensationElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT);
        if(obsGCPsNodes.size()==0)
        {
            strError+=QObject::tr("No tag %1 in compensation stage %2 the file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        if(obsGCPsNodes.size()>1)
        {
            strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in file %3")
                    .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                    .arg(QString::number(nec+1))
                    .arg(aperoParamsFileName);
            return(false);
        }
        QDomNode obsGCPsNode=obsGCPsNodes.at(0);
        QDomElement obsGCPsElement=obsGCPsNode.toElement();
        {
            QDomNodeList nbMaxNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX);
            if(nbMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(nbMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_NBMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode nbMaxNode=nbMaxNodes.at(0);
            if(nec==0)
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_GCPS_STAGE_0_VALUE);
            else
                nbMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_NBMAX_GCPS_STAGE_1_VALUE);

            QDomNodeList sigmaPondNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND);
            if(sigmaPondNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(sigmaPondNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_SIGMAPOND)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode sigmaPondNode=sigmaPondNodes.at(0);
            if(nec==0)
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_0_VALUE);
            else
                sigmaPondNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_SIGMAPOND_GCPS_STAGE_1_VALUE);

            QDomNodeList ecartMaxNodes=obsGCPsElement.elementsByTagName(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX);
            if(ecartMaxNodes.size()==0)
            {
                strError+=QObject::tr("No tag %1 in compensation stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            if(ecartMaxNodes.size()>1)
            {
                strError+=QObject::tr("\nThere are more than one %1 node in stage %2 in observations %3 in file %4")
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_ECARTMAX)
                        .arg(QString::number(nec+1))
                        .arg(LIPPW_APERO_PARAMETERS_FILE_TAG_OBSAPPUISFLOTTANT)
                        .arg(aperoParamsFileName);
                return(false);
            }
            QDomNode ecartMaxNode=ecartMaxNodes.at(0);
            if(nec==0)
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_0_VALUE);
            else
                ecartMaxNode.setNodeValue(LIPPW_APERO_PARAMETERS_FILE_ECARTMAX_GCPS_STAGE_1_VALUE);
        }
        aperoDoc.replaceChild(etapeCompensationNode,etapeCompensationNode);
    }
    const int IndentSize = 4;
    if (!newAperoParamsFile.open(QFile::WriteOnly | QFile::Text))
    {
        strError=QObject::tr("Error opening file:\n%1").arg(aperoParamsFileName);
        return(false);
    }
    QTextStream out(&newAperoParamsFile);
    aperoDoc.save(out, IndentSize);
    newAperoParamsFile.close();

//        QList<QParams::Param *> params = getOrientationsDialog()->getAdvancedParams().values();
//        for(int i=0; i< params.count(); i++){
//            QParams::ContinuousParam *param = dynamic_cast<QParams::ContinuousParam*>(params.at(i));
//            replace(&AperoParamsFile, &AperoParamsFile,param->getName(),
//                    QString::number(param->getValue()));
//        }
*/
    return(true);
}

bool OrientationProcessMonitor::writeHomol(QString& strError)
{
    QString homolPath= mTmpFolder + "/" + "Homol";
    if(!removeDir(homolPath))
    {
        strError=QObject::tr("Error removing existing directory for matches in Apero format");
        return(false);
    }
    QDir homolDir(homolPath);
    if(!homolDir.exists())
    {
        if(!homolDir.mkdir(homolPath))
        {
            strError=QObject::tr("Error making directory for Apero");
            return(false);
        }
    }
    if(TIEPOINTSIO_NO_ERROR!=PW::TiePointsIO::writeHomolOrtoSky(homolPath,
                                                                mImageFileNameWithoutPathsByName,
                                                                mImagesIdsTiePoints,
                                                                mImagesFirstColumnsTiePoints,
                                                                mImagesFirstRowsTiePoints,
                                                                mImagesSecondColumnsTiePoints,
                                                                mImagesSecondRowsTiePoints,
                                                                strError))
    {
        return(false);
    }
    return(true);
}

bool OrientationProcessMonitor::writeImageMasterImageCoordinates(QDomElement& cameraModelXmlElement,
                                                                 QString &strError)
{
    if(!mLibSDGAP->writeImageMasterImageCoordinates(mTmpFolder,//mProjectPath,
                                                    strError))
    {
        return(false);
    }
    // Impresión del fichero de la cámara
    // Lectura de la orientacion interna
    QString calibrationId=cameraModelXmlElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID).trimmed();
    Camera *camera = mImages.at(0)->getCamera();
    AperoModelReader interiorReader(camera);
    QDomElement auxCameraModelXmlElement;
    {
        QDomNodeList auxNodes=cameraModelXmlElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
        QDomNode calibrationNode=auxNodes.at(0);
        auxCameraModelXmlElement=calibrationNode.toElement();
    }
    CameraModel *cameraModel = interiorReader.read(auxCameraModelXmlElement);
    if (cameraModel == NULL)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeImageMasterImageCoordinates, error reading interior orientation id:\n%1").arg(calibrationId);
        return(false);
    }
    QString cameraType=LIBSDGAP_CAMERA_TYPE_CCD;
    //QString cameraId=camera->getName()+"_"+calibrationId;
    QString cameraId=camera->getName();
    QString cameraName=camera->getName();
    int columns=mSensorSize.width();
    int rows=mSensorSize.height();
    double xPixelSize_mm=camera->getSensorWidth()/((double)columns); // en mm
    double yPixelSize_mm=camera->getSensorHeight()/((double)rows); // en mm
    double focal_mm,xPPA_mm,yPPA_mm;
    double k1_mm=0.0;
    double k2_mm=0.0;
    double k3_mm=0.0;
    double p1_mm=0.0;
    double p2_mm=0.0;
    double b1_mm=0.0;
    double b2_mm=0.0;
    if(!mLibSDGAP->getPBAResults(focal_mm,xPPA_mm,yPPA_mm,k1_mm,k2_mm,k3_mm,p1_mm,p2_mm,b1_mm,b2_mm,strError))
    {
        strError=QObject::tr("OrientationProcessMonitor::writeImageMasterImageCoordinates, error reading results from SDGAP");
        return(false);
    }
    QString cmrFileName=mTmpFolder+"/"+cameraName+".cmr";
    QFile cmrFile(cmrFileName);
    if (!cmrFile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        strError=QObject::tr("OrientationProcessMonitor::writeImageMasterImageCoordinates, error creating file:\n%1").arg(cmrFileName);
        return(false);
    }
    double xPPA_mm_fromULCorner=columns/2.0*xPixelSize_mm+xPPA_mm;
    double yPPA_mm_fromULCorner=rows/2.0*yPixelSize_mm-yPPA_mm;
    k1_mm=k1_mm*1.0e-6;
    k2_mm=k1_mm*1.0e-12;
    k3_mm=k1_mm*1.0e-18;
    p1_mm=p1_mm*1.0e-3;
    p2_mm=p2_mm*1.0e-3;
    QTextStream out(&cmrFile);
    out<<QString::number(focal_mm,'f',6)<<"			// focal length [mm]\n";
    out<<QString::number(xPPA_mm_fromULCorner,'f',6)<<"			// x of principal point [mm]\n";
    out<<QString::number(yPPA_mm_fromULCorner,'f',6)<<"			// y of principal point [mm]\n";
    out<<"3"<<"			// distortion model\n";
    out<<"5"<<"			// number of distortion parameters\n";
    out<<QString::number(k1_mm,'g',6)<<"		// parameter k1\n";
    out<<QString::number(k2_mm,'g',6)<<"		// parameter k2\n";
    out<<QString::number(k3_mm,'g',6)<<"		// parameter k3\n";
    out<<QString::number(p1_mm,'g',6)<<"		// parameter p1\n";
    out<<QString::number(p2_mm,'g',6)<<"		// parameter p2\n";
    out<<QString::number(xPixelSize_mm,'f',6)<<"			// x resolution [mm/pixel]\n";
    out<<QString::number(yPixelSize_mm,'f',6)<<"			// y resolution [mm/pixel]\n";
    out<<"0"<<"			// number of fiducial marks\n";
    out<<"0"<<"			// number of radial distortion values\n";
    cmrFile.close();
    return(true);
}

bool OrientationProcessMonitor::writeSourceOrientation(QString &strError)
{
    QString orientationId=mSourceOrientation;
    QString calibrationId=mSourceCalibration; // será todavía null
    bool writeEOs=mUseGroundControl;

    // Lectura del nodo photography
    QDomNodeList photographyNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PHOTOGRAPHY);
    if(photographyNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node photography");
        return(false);
    }
    QDomNode photographyNode=photographyNodes.at(0);
    QDomElement photographyElement=photographyNode.toElement();

    // Lectura del nodo sessions
    QDomNodeList sessionsNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSIONS);
    if(sessionsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sessions");
        return(false);
    }
    QDomNode sessionsNode=sessionsNodes.at(0);
    QDomElement sessionsElement=sessionsNode.toElement();

    QDomElement sessionElement;
    // Lectura del nodo session
    QDomNodeList sessionNodes=sessionsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SESSION);
    if(sessionsNodes.size()<1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session");
        return(false);
    }
    bool findSession=false;
    for(int nSessionNode=0;nSessionNode<sessionNodes.size();nSessionNode++)
    {
        QDomNode sessionNode=sessionNodes.at(nSessionNode);
        QDomElement auxSessionElement=sessionNode.toElement();
        QString sessionName=auxSessionElement.attribute(ORTOSKYXMLMATCHESFILE_TAG_SESSION_ATTRIBUTE_NAME).trimmed();
        if(sessionName.compare(mSessionName,Qt::CaseInsensitive)==0)
        {
            if(findSession)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nNode session with name %1 is repeat").arg(mSessionName);
                return(false);
            }
            sessionElement=auxSessionElement;
            findSession=true;
        }
    }
    if(!findSession)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo node session with name %1").arg(mSessionName);
        return(false);
    }

    QString orientationFolder=mTmpFolder+"/"+TAPIOCA_ORIENTATION_PREFIX_FOLDER+orientationId;
//    QString orientationFolder=mImagesPath+"/"+TAPIOCA_ORIENTATION_PREFIX_FOLDER+calibrationId;
    QDir auxDir=QDir::currentPath();
    if(auxDir.exists(orientationFolder))
    {
        if(!removeDir(orientationFolder))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error removing folder:\n%1").arg(orientationFolder);
            return(false);
        }
    }
    if(!auxDir.mkdir(orientationFolder))
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error creation folder:\n%1").arg(orientationFolder);
        return(false);
    }
    addPathToRemove(orientationFolder);

    // Almacenamiento de las orientaciones en las imágenes
    QDomNodeList imagesNodes=sessionElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGES);
    if(imagesNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag images in the session name %1").arg(mSessionName);
        return(false);
    }
    if(imagesNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one images node in session name %1").arg(mSessionName);
        return(false);
    }
    QDomNode imagesNode=imagesNodes.at(0);
    QDomElement imagesElement=imagesNode.toElement();
    QDomNodeList imageNodes=imagesElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE);
    if(imageNodes.size()<2)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
        strError+=QObject::tr("\nIn node images must be more than one image nodes");
        return(false);
    }
    QString sourceInOrientations;
    for(int nImageNode=0;nImageNode<imageNodes.size();nImageNode++)
    {
        QDomNode imageNode=imageNodes.at(nImageNode);
        if(!imageNode.isElement())
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("Image node number %1 is not an element").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageElement=imageNode.toElement();
        QDomNodeList imageNameNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_NAME);
        if(imageNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a name node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement imageNameElement=imageNameNodes.at(0).toElement();
        QString imageName=imageNameElement.text().trimmed();
        if(!mImageNames.contains(imageName))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, image name %2 is not valid").arg(QString::number(nImageNode+1)).arg(imageName);
            return(false);
        }
        QString imageFileNameWithoutPath=mImageFileNameWithoutPathsByName[imageName];
        QDomNodeList shotNodes=imageElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_SHOT);
        if(shotNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there is not a shot node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement shotElement=shotNodes.at(0).toElement();
        QDomNodeList orientationsNodes=shotElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATIONS);
        if(orientationsNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, there are not one orientations node").arg(QString::number(nImageNode+1));
            return(false);
        }
        QDomElement orientationsElement=orientationsNodes.at(0).toElement();
        QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        QDomElement orientationElement;
        QDomNode imageOrientationNode;
        bool findOrientation=false;
        for(int nC=0;nC<orientationNodes.size();nC++)
        {
            QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
            QString strName=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_NAME).trimmed();
            if(strName.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                strError+=QObject::tr("\nIn image node number %1, not found name attribute").arg(QString::number(nImageNode+1));
                return(false);
            }
            if(strName.compare(orientationId)==0)
            {
                orientationElement=auxOrientationElement;
                QDomNodeList auxNodes=orientationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
                if(auxNodes.size()!=1)
                {
                    strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
                    strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                    strError+=QObject::tr("\nIn image node number %1, not found tag %2")
                            .arg(QString::number(nImageNode+1)).arg(APERO_XMLFILES_TAG_EXPORT_APERO);
                    return(false);
                }
                imageOrientationNode=auxNodes.at(0);
                findOrientation=true;
                break;
            }
        }
        if(!findOrientation)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, not found orientation %2")
                    .arg(QString::number(nImageNode+1))
                    .arg(orientationId);
            return(false);
        }
        QString sourceInOrientation=orientationElement.attribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_CALIBRATION).trimmed();
        if(sourceInOrientation.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
            strError+=QObject::tr("\nIn image node number %1, in orientation %2 not found calibration attribute")
                    .arg(QString::number(nImageNode+1))
                    .arg(orientationId);
            return(false);
        }
        if(sourceInOrientations.isEmpty())
            sourceInOrientations=sourceInOrientation;
        else
        {
            if(sourceInOrientation.compare(sourceInOrientations)!=0)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nReading session node name %1").arg(mSessionName);
                strError+=QObject::tr("\nIn image node number %1, in orientation %2 calibration attribute is differente from previous images")
                        .arg(QString::number(nImageNode+1))
                        .arg(orientationId);
                return(false);
            }
        }
        if(writeEOs)
        {
            QString fileName=TAPIOCA_ORIENTATION_PREFIX_FILE+imageFileNameWithoutPath+".xml";
            QString imageOrientationFileName=orientationFolder+"/"+fileName;
            const int IndentSize = 4;
            QFile file(imageOrientationFileName);
            if (!file.open(QFile::WriteOnly | QFile::Text))
            {
                strError=tr("Error opening xml file:\n%1").arg(imageOrientationFileName);
                return(false);
            }
            QTextStream out(&file);
            out<<APERO_XMLFILES_FIRST_LINE<<endl;
        //    QDomDocument dom;
        //    dom.appendChild(calibrationElement);
        //    dom.save(out, IndentSize);
            imageOrientationNode.save(out,IndentSize);
            file.close();
        }
    }
    mSourceCalibration=sourceInOrientations;

    QDomNodeList camerasNodes=photographyElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCES);
    if(camerasNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nShould be only one node sources");
        return(false);
    }
    QDomNode camerasNode=camerasNodes.at(0);
    QDomElement camerasElement=camerasNode.toElement();

    // Lectura de la información de la cámara
    QDomNodeList cameraNodes=camerasElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_SOURCE);
    if(cameraNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag source in the file");
        return(false);
    }
    QDomNode cameraNode;
    bool findCamera=false;
    for(int nCamera=0;nCamera<cameraNodes.size();nCamera++)
    {
        QDomNode auxCameraNode=cameraNodes.at(nCamera);
        QDomElement cameraElement=auxCameraNode.toElement();

        // Lectura del nombre de la cámara
        QDomNodeList cameraNameNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CAMERA_NAME);
        if(cameraNameNodes.size()!=1)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nReading source node number %1").arg(QString::number(nCamera+1));
            strError+=QObject::tr("\nSource name node is not unique");
            return(false);
        }
        QDomNode cameraNameNode=cameraNameNodes.at(0);
        QString cameraName=cameraNameNode.toElement().text().trimmed();
        if(cameraName.compare(mCameraName,Qt::CaseInsensitive)==0)
        {
            findCamera=true;
            cameraNode=auxCameraNode;
        }
    }
    if(!findCamera)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo source %1 in the file").arg(mCameraName);
        return(false);
    }
    QDomElement cameraElement=cameraNode.toElement();

    QDomNodeList calibrationsNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
    if(calibrationsNodes.size()!=1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are not one than one calibrations nodes in camera %1 node").arg(mCameraName);
        return(false);
    }
    QDomElement calibrationsElement=calibrationsNodes.at(0).toElement();
    QDomNodeList calibrationNodes=calibrationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
    QDomElement calibrationElement;
    QDomNode calibrationNode;
    bool findCalibrationElement=false;
    for(int nC=0;nC<calibrationNodes.size();nC++)
    {
        QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
        QString strName=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_NAME).trimmed();
        if(strName.isEmpty())
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
            strError+=QObject::tr("\nIn camera %1 Calibration node number %2, not found name attribute")
                    .arg(mCameraName).arg(QString::number(nC+1));
            return(false);
        }
        if(strName.compare(mSourceCalibration)==0)
        {
            calibrationElement=auxCalibrationElement;
            QDomNodeList auxNodes=calibrationElement.elementsByTagName(APERO_XMLFILES_TAG_EXPORT_APERO);
            if(auxNodes.size()!=1)
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nIn camera %1 Calibration node number %2, not found tag %3")
                        .arg(mCameraName).arg(QString::number(nC+1)).arg(APERO_XMLFILES_TAG_EXPORT_APERO);
                return(false);
            }
            calibrationNode=auxNodes.at(0);
            findCalibrationElement=true;
            break;
        }
    }
    if(!findCalibrationElement)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSourceOrientation, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nIn source %1 there are not calibration %2").arg(mCameraName).arg(mSourceCalibration);
        return(false);
    }
    QString attributeFileName=calibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_APERO_FILENAME).trimmed();
    QString calibrationFileName=orientationFolder+"/"+attributeFileName;

    const int IndentSize = 4;
    QFile file(calibrationFileName);
    if (!file.open(QFile::WriteOnly | QFile::Text))
    {
        strError=tr("Error opening xml file:\n%1").arg(calibrationFileName);
        return(false);
    }
    QTextStream out(&file);
    out<<APERO_XMLFILES_FIRST_LINE<<endl;
//    QDomDocument dom;
//    dom.appendChild(calibrationElement);
//    dom.save(out, IndentSize);
    calibrationNode.save(out,IndentSize);
    file.close();

    return(true);
}

bool OrientationProcessMonitor::convertInFirstImage(QString &noFirstImage,
                                                    QVector<QString> &noFirstImages,
                                                    QMap<QString, QVector<QString> > &imagesIdsTiePoints)
{
    if(imagesIdsTiePoints.contains(noFirstImage)) // no tiene sentido, no hay problema a resolver
        return(true);
    // 1. Encuentro qué imagen la contiene y tiene un mayor número de conexiones
    QString containerImage;
    int maxNumberOfConnections=0;
    QMap<QString, QVector<QString> >::Iterator iter=imagesIdsTiePoints.begin();
    int noFirstImagePosition=-1;
    while(iter!=imagesIdsTiePoints.end())
    {
        QString auxImage=iter.key();
        QVector<QString> images=iter.value();
        int noFirstImagePositionInImages=images.indexOf(noFirstImage);
        if(noFirstImagePositionInImages!=-1)
        {
            int numberOfConnections=iter.value().size();
            if(numberOfConnections>maxNumberOfConnections)
            {
                maxNumberOfConnections=numberOfConnections;
                containerImage=auxImage;
                noFirstImagePosition=noFirstImagePositionInImages;
            }
        }
        iter++;
    }
    bool success=false;
    if(maxNumberOfConnections>0)
    {
        imagesIdsTiePoints[containerImage].remove(noFirstImagePosition);
        QVector<QString> images;
        images.push_back(containerImage);
        imagesIdsTiePoints[noFirstImage]=images;
        int posToRemove=noFirstImages.indexOf(noFirstImage);
        noFirstImages.remove(posToRemove);
        if(maxNumberOfConnections==1)
        {
            success=convertInFirstImage(noFirstImage,noFirstImages,imagesIdsTiePoints);
        }
        else
            success=true;
    }
    return(success);
}

void OrientationProcessMonitor::sensor_to_image_sdgap(int columns,
                                                      int rows,
                                                      double xPixelSize_mc,
                                                      double yPixelSize_mc,
                                                      double& img_c_x,
                                                      double& img_c_y)
{
    int _nc=columns;
    int _nr=rows;
    double _c0 = (_nc - 1) / 2.;
    double _r0 = (_nr - 1) / 2.;
    double sen_c_x=img_c_x;
    double sen_c_y=img_c_y;
    double _sc=xPixelSize_mc;
    double _sr=yPixelSize_mc;
    img_c_x =   (sen_c_x - _c0) * _sc;
    img_c_y = - (sen_c_y - _r0) * _sr;
}

void OrientationProcessMonitor::image_to_sensor_sdgap(int columns,
                                                      int rows,
                                                      double xPixelSize_mc,
                                                      double yPixelSize_mc,
                                                      double& img_c_x,
                                                      double& img_c_y)
{
    int _nc=columns;
    int _nr=rows;
    double _c0 = (_nc - 1) / 2.;
    double _r0 = (_nr - 1) / 2.;
    double _sc=xPixelSize_mc;
    double _sr=yPixelSize_mc;
    double sen_c_x=img_c_x/_sc+_c0;
    double sen_c_y=_r0-img_c_y/_sr;
    img_c_x=sen_c_x;
    img_c_y=sen_c_y;
}

void OrientationProcessMonitor::image_to_photo_sdgap(double focal_m,
                                                     double xPPAFromCenter_m,
                                                     double yPPAFromCenter_m,
                                                     double& pho_c_x,
                                                     double& pho_c_y,
                                                     double& pho_c_z)
{
    double _princ_dist=focal_m;
    double _princ_pnt_x=xPPAFromCenter_m;
    double _princ_pnt_y=yPPAFromCenter_m;
    pho_c_x = pho_c_x - _princ_pnt_x;
    pho_c_y = pho_c_y - _princ_pnt_y;
    pho_c_z = -_princ_dist;
}

void OrientationProcessMonitor::photo_to_image_sdgap(double xPPAFromCenter_m,
                                                     double yPPAFromCenter_m,
                                                     double& pho_c_x,
                                                     double& pho_c_y)
{
    double _princ_pnt_x=xPPAFromCenter_m;
    double _princ_pnt_y=yPPAFromCenter_m;
    pho_c_x = pho_c_x + _princ_pnt_x;
    pho_c_y = pho_c_y + _princ_pnt_y;
}

void OrientationProcessMonitor::undistort_sdgap(double diff_xPPA,
                                                double diff_yPPA,
                                                double diff_focal,
                                                double k1,
                                                double k2,
                                                double k3,
                                                double p1,
                                                double p2,
                                                double b1,
                                                double b2,
                                                double& pho_c_x,
                                                double& pho_c_y,
                                                double pho_c_z)
{

    double cor_x = 0.;
    double cor_y = 0.;
    bool control=true;
    double tolerance=1.8e-6/10.0;
    while(control)
    {
        double pho_c_x_c =pho_c_x- cor_x;
        double pho_c_y_c =pho_c_y- cor_y;

        double xb = pho_c_x_c;
        double yb = pho_c_y_c;
        double zb = pho_c_z;
        double xb2 = xb * xb;
        double yb2 = yb * yb;
        double r2 = xb2 + yb2;
        double r4 = r2 * r2;
        double r6 = r4 * r2;

        double derivs_0_0 = 1.;
        double derivs_0_1 = 0.;
        double derivs_0_2 = - xb / zb;
        double derivs_0_3 = xb * r2;
        double derivs_0_4 = xb * r4;
        double derivs_0_5 = xb * r6;
        double derivs_0_6 = 2. * xb2 + r2;
        double derivs_0_7 = 2. * xb * yb;
        double derivs_0_8 = xb;
        double derivs_0_9 = yb;

        double derivs_1_0 = 0.;
        double derivs_1_1 = 1.;
        double derivs_1_2 = - yb / zb;
        double derivs_1_3 = yb * r2;
        double derivs_1_4 = yb * r4;
        double derivs_1_5 = yb * r6;
        double derivs_1_6 = 2. * xb * yb;
        double derivs_1_7 = 2. * yb2 + r2;
        double derivs_1_8 = 0.;
        double derivs_1_9 = 0.;

        double cor_x_bis = 0.;
        double cor_y_bis = 0.;

        cor_x_bis += derivs_0_0 * diff_xPPA;
        cor_x_bis += derivs_0_1 * diff_yPPA;
        cor_x_bis += derivs_0_2 * diff_focal;
        cor_x_bis += derivs_0_3 * k1;
        cor_x_bis += derivs_0_4 * k2;
        cor_x_bis += derivs_0_5 * k3;
        cor_x_bis += derivs_0_6 * p1;
        cor_x_bis += derivs_0_7 * p2;
        cor_x_bis += derivs_0_8 * b1;
        cor_x_bis += derivs_0_9 * b2;

        cor_y_bis += derivs_1_0 * diff_xPPA;
        cor_y_bis += derivs_1_1 * diff_yPPA;
        cor_y_bis += derivs_1_2 * diff_focal;
        cor_y_bis += derivs_1_3 * k1;
        cor_y_bis += derivs_1_4 * k2;
        cor_y_bis += derivs_1_5 * k3;
        cor_y_bis += derivs_1_6 * p1;
        cor_y_bis += derivs_1_7 * p2;
        cor_y_bis += derivs_1_8 * b1;
        cor_y_bis += derivs_1_9 * b2;

        double diff_cor_x=cor_x_bis-cor_x;
        double diff_cor_y=cor_y_bis-cor_y;
        cor_x=cor_x_bis;
        cor_y=cor_y_bis;
        if(fabs(diff_cor_x)<tolerance
                &&fabs(diff_cor_y)<tolerance)
            control=false;
    }

    pho_c_x -= cor_x;
    pho_c_y -= cor_y;
}

bool OrientationProcessMonitor::updateGCPPointsAccuracySDGAP(QString &strError)
{
    // actualiza mGeometryGCPs pasando de (x,y,z,sx,sy,sz) a (x,y,z,sx,sy,sz,ex,ey,ez,e2d)
    // actualiza mImageCoordinatesGCPs de (x,y,std) a (x,y,std,ex,ey,e2d)
    QMap<QString, QVector<float> >::iterator iter=mGeometryGCPs.begin();
    while(iter!=mGeometryGCPs.end())
    {
        QString gcpName=iter.key();
        if(!mImageCoordinatesGCPs.contains(gcpName))
        {
            //strError=QObject::tr("OrientationProcessMonitor::updateGCPPointsAccuracy:: not measurement for GCP:%1").arg(gcpName);
            iter++;
            continue;
        }
        float xT=iter.value()[0];
        float yT=iter.value()[1];
        float zT=iter.value()[2];
        QMap<QString, QVector<float> > imageCoordinatesGCP=mImageCoordinatesGCPs[gcpName];
        QMap<QString, QVector<float> >::iterator iterIc=imageCoordinatesGCP.begin();
        // Primero cuento las imágenes para dimensionar la matriz
        int numberOfMeasuredImages=0;
        while(iterIc!=imageCoordinatesGCP.end())
        {
            QString imageId=iterIc.key();
            if(!mImagesByName.contains(imageId))
            {
                strError=QObject::tr("OrientationProcessMonitor::updateGCPPointsAccuracy:: In GCP:%1 not found measured image %2")
                        .arg(gcpName)
                        .arg(imageId);
                return(false);
            }
            numberOfMeasuredImages++;
            iterIc++;
        }
        Eigen::MatrixXd A(2*numberOfMeasuredImages,3);
        Eigen::VectorXd b(2*numberOfMeasuredImages);
        int numberOfLine=0;
        iterIc=imageCoordinatesGCP.begin();
        while(iterIc!=imageCoordinatesGCP.end())
        {
            QString imageId=iterIc.key();
            numberOfMeasuredImages++;
            float x=iterIc.value()[0];
            float y=iterIc.value()[1];
            PW::PWImage* image=mImagesByName[imageId];
            int imageWidth=image->getSize().width();
            int imageHeight=image->getSize().height();
            PW::PhotogrammetricModel *pm=(PhotogrammetricModel *)image->getCamera()->getCameraModel();
            PW::Camera *camera = image->getCamera();
            double sensorWidth_mm=camera->getSensorWidth();
            double sensorHeight_mm=camera->getSensorHeight();
            double xPixelSize_mm=sensorWidth_mm/((double)imageWidth); // en mm
            double yPixelSize_mm=sensorHeight_mm/((double)imageHeight); // en mm
            double xPixelSize_mc=xPixelSize_mm*1e-3;
            double yPixelSize_mc=yPixelSize_mm*1e-3;
            double focal_pixel=pm->getFocal();
            double focal_mm=focal_pixel*xPixelSize_mm;
    //        double firstImageFocal_m=firstImageFocal_mm*1e-3;
            double xPPA_ul_pixel=pm->getXp();
            double yPPA_ul_pixel=pm->getYp();
    //        double firstImageXPPAFromCenter_mm=(firstImageXPPA_ul_pixel-((double)firstImageWidth)/2.0)*firstImageXPixelSize_mm;
    //        double firstImageYPPAFromCenter_mm=(((double)firstImageHeight)/2.0-firstImageYPPA_ul_pixel)*firstImageXPixelSize_mm;
    //        double xPPAFromCenter_m=xPPAFromCenter_mm*1e-3;
    //        double yPPAFromCenter_m=yPPAFromCenter_mm*1e-3;
            double xPPAFromCenter_m=(xPPA_ul_pixel-((double)imageWidth)/2.0)*xPixelSize_mc;
            double yPPAFromCenter_m=-(yPPA_ul_pixel - ((double)imageHeight)/2.0)*yPixelSize_mc;
            double focal_m=focal_pixel*xPixelSize_mc;
            double diff_focal_m=0.0;
            double diff_xPPA_m=0.0;
            double diff_yPPA_m=0.0;
            PW::DistortionModel* distortionModel=pm->getDistortionModel();
            double k1_pixel=((FraserModel*)distortionModel)->getK1();
            double k2_pixel=((FraserModel*)distortionModel)->getK2();
            double k3_pixel=((FraserModel*)distortionModel)->getK3();
            double p1_pixel=((FraserModel*)distortionModel)->getP1();
            double p2_pixel=((FraserModel*)distortionModel)->getP2();
            double b1_pixel=((FraserModel*)distortionModel)->getB1();
            double b2_pixel=((FraserModel*)distortionModel)->getB2();
            double k1=k1_pixel/pow(xPixelSize_mm,2.0)/pow(xPixelSize_mm,2.0);
            double k2=k2_pixel/pow(xPixelSize_mm,4.0)/pow(xPixelSize_mm,4.0);
            double k3=k3_pixel/pow(xPixelSize_mm,6.0)/pow(xPixelSize_mm,6.0);
            double p1=p1_pixel/xPixelSize_mm/xPixelSize_mm;
            double p2=p2_pixel/xPixelSize_mm/xPixelSize_mm;
            double b1=b1_pixel;//xPixelSize_mm;
            double b2=b2_pixel;//xPixelSize_mm;
            QVector< QVector<double> > * r = image->getExteriorOrientation()->getR();
            QVector<double> * cp = image->getExteriorOrientation()->getCP();
            double xL=(*cp)[0]; // coordenadas del centro de proyección de la imagen
            double yL=(*cp)[1];
            double zL=(*cp)[2];
            double r11=(*r)[0][0]; // matriz de rotación
            double r12=-1.0*(*r)[0][1];
            double r13=-1.0*(*r)[0][2];
            double r21=(*r)[1][0];
            double r22=-1.0*(*r)[1][1];
            double r23=-1.0*(*r)[1][2];
            double r31=(*r)[2][0];
            double r32=-1.0*(*r)[2][1];
            double r33=-1.0*(*r)[2][2];

            // 1. Paso de coordenadas sensor (CCD) a imagen (respecto al centro físico, en mm y con la y invertida)
            double img_c_x=x;
            double img_c_y=y;
            sensor_to_image_sdgap(imageWidth,imageHeight,
                                  xPixelSize_mc,yPixelSize_mc,
                                  img_c_x,img_c_y);

            // 2. Paso a coordenadas Photo, referidas al PPA y con la focal
            double pho_c_x=img_c_x;
            double pho_c_y=img_c_y;
            double pho_c_z=0.0;
            image_to_photo_sdgap(focal_m,
                                 xPPAFromCenter_m,yPPAFromCenter_m,
                                 pho_c_x,pho_c_y,pho_c_z);

            // 3. Eliminación de la distorsión
            undistort_sdgap(diff_xPPA_m,diff_yPPA_m,diff_focal_m,
                            k1,k2,k3,p1,p2,b1,b2,
                            pho_c_x,pho_c_y,pho_c_z);

            double xi=pho_c_x;
            double yi=pho_c_y;
            double focal=pho_c_z;
            double a=r11*xi+r12*yi+r13*focal;
            double d=r21*xi+r22*yi+r23*focal;
            double c=r31*xi+r32*yi+r33*focal;
            A(numberOfLine,0) = c;
            A(numberOfLine,1) = 0.0;
            A(numberOfLine,2) = -1.0*a;
            A(numberOfLine+1,0) = 0.0;
            A(numberOfLine+1,1) = c;
            A(numberOfLine+1,2) = -1.0*d;
            b(numberOfLine)=c*cp->at(0)-a*cp->at(2);
            b(numberOfLine+1)=c*cp->at(1)-d*cp->at(2);
            numberOfLine=numberOfLine+2;

            // 1. Coordenadas photo
            double pho_c_z_b= focal; //-1.0*focal_1; // porque ya está puesto a negativo
            double pho_c_x_b= pho_c_z*(r11*(xT-xL)+r21*(yT-yL)+r31*(zT-zL))/(r13*(xT-xL)+r23*(yT-yL)+r33*(zT-zL));
            double pho_c_y_b= pho_c_z*(r12*(xT-xL)+r22*(yT-yL)+r32*(zT-zL))/(r13*(xT-xL)+r23*(yT-yL)+r33*(zT-zL));
            // 2. Añadir la distorsión
            distort_sdgap(diff_xPPA_m,diff_yPPA_m,diff_focal_m,
                          k1,k2,k3,p1,p2,b1,b2,
                          pho_c_x_b,pho_c_y_b,pho_c_z_b);
            // 3. De photo a image
            double img_c_x_b=pho_c_x_b;
            double img_c_y_b=pho_c_y_b;
            photo_to_image_sdgap(xPPAFromCenter_m,yPPAFromCenter_m,
                                 img_c_x_b,img_c_y_b);
            // 4. De image a sensor
            double sen_c_x_b=img_c_x_b;
            double sen_c_y_b=img_c_y_b;
            image_to_sensor_sdgap(imageWidth,imageHeight,
                                  xPixelSize_mc,yPixelSize_mc,
                                  sen_c_x_b,sen_c_y_b);
            float xi_backward=sen_c_x_b;
            float yi_backward=sen_c_y_b;
            float xi_error=iterIc.value()[0]-xi_backward;
            float yi_error=iterIc.value()[1]-yi_backward;
            float i_accuracy=sqrt(xi_error*xi_error+yi_error*yi_error);
            mImageCoordinatesGCPs[gcpName][imageId].push_back(xi_error);
            mImageCoordinatesGCPs[gcpName][imageId].push_back(yi_error);
            mImageCoordinatesGCPs[gcpName][imageId].push_back(i_accuracy);
            iterIc++;
        }
        Eigen::VectorXd sol=(A.transpose() * A).ldlt().solve(A.transpose() * b);
        Eigen::VectorXd residuals=A*sol-b;
        double res2d=sqrt(residuals(0)*residuals(0)+residuals(1)*residuals(1)+residuals(2)*residuals(2)+residuals(3)*residuals(3));
        double xTc=sol(0);
        double yTc=sol(1);
        double zTc=sol(2);
        float ex=xT-xTc;
        float ey=yT-yTc;
        float ez=zT-zTc;
        float e2d=sqrt(ex*ex+ey*ey);
        mGeometryGCPs[gcpName].push_back(ex);
        mGeometryGCPs[gcpName].push_back(ey);
        mGeometryGCPs[gcpName].push_back(ez);
        mGeometryGCPs[gcpName].push_back(e2d);
        iter++;
    }
    return(true);
}

void OrientationProcessMonitor::distort_sdgap(double diff_xPPA,
                                              double diff_yPPA,
                                              double diff_focal,
                                              double k1,
                                              double k2,
                                              double k3,
                                              double p1,
                                              double p2,
                                              double b1,
                                              double b2,
                                              double& pho_c_x,
                                              double& pho_c_y,
                                              double pho_c_z)
{

    double xb = pho_c_x;
    double yb = pho_c_y;
    double zb = pho_c_z;
    double xb2 = xb * xb;
    double yb2 = yb * yb;
    double r2 = xb2 + yb2;
    double r4 = r2 * r2;
    double r6 = r4 * r2;

    double derivs_0_0 = 1.;
    double derivs_0_1 = 0.;
    double derivs_0_2 = - xb / zb;
    double derivs_0_3 = xb * r2;
    double derivs_0_4 = xb * r4;
    double derivs_0_5 = xb * r6;
    double derivs_0_6 = 2. * xb2 + r2;
    double derivs_0_7 = 2. * xb * yb;
    double derivs_0_8 = xb;
    double derivs_0_9 = yb;

    double derivs_1_0 = 0.;
    double derivs_1_1 = 1.;
    double derivs_1_2 = - yb / zb;
    double derivs_1_3 = yb * r2;
    double derivs_1_4 = yb * r4;
    double derivs_1_5 = yb * r6;
    double derivs_1_6 = 2. * xb * yb;
    double derivs_1_7 = 2. * yb2 + r2;
    double derivs_1_8 = 0.;
    double derivs_1_9 = 0.;

    double cor_x = 0.;
    double cor_y = 0.;

    cor_x += derivs_0_0 * diff_xPPA;
    cor_x += derivs_0_1 * diff_yPPA;
    cor_x += derivs_0_2 * diff_focal;
    cor_x += derivs_0_3 * k1;
    cor_x += derivs_0_4 * k2;
    cor_x += derivs_0_5 * k3;
    cor_x += derivs_0_6 * p1;
    cor_x += derivs_0_7 * p2;
    cor_x += derivs_0_8 * b1;
    cor_x += derivs_0_9 * b2;

    cor_y += derivs_1_0 * diff_xPPA;
    cor_y += derivs_1_1 * diff_yPPA;
    cor_y += derivs_1_2 * diff_focal;
    cor_y += derivs_1_3 * k1;
    cor_y += derivs_1_4 * k2;
    cor_y += derivs_1_5 * k3;
    cor_y += derivs_1_6 * p1;
    cor_y += derivs_1_7 * p2;
    cor_y += derivs_1_8 * b1;
    cor_y += derivs_1_9 * b2;
    pho_c_x += cor_x;
    pho_c_y += cor_y;
}

/*

bool OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile(QDomElement& cameraModelXmlElement,
                                                              QMap<QString,QDomElement>& exteriorOrientationXmlElements,
                                                              QString& strError)
{
    QString calibrationEngine=mCalibrationEngines[mCalibrationEngines.size()-1];
    QString calibrationModel=mCalibrationModels[mCalibrationModels.size()-1];
    QString calibrationId=mCalibrationIds[mCalibrationIds.size()-1];
    QMap<int,QString>::const_iterator iter=mImagesFileNameByPos.begin();
    while(iter!=mImagesFileNameByPos.end())
    {
        QString imageId=iter.value();
        if(!exteriorOrientationXmlElements.contains(imageId))
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile,\n");
            strError+=QObject::tr("No image %1 in exterior orientations container").arg(imageId);
            return(false);
        }
        iter++;
    }

    // Grabación de la información de la calibración de la cámara
    QDomNodeList cameraNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CAMERA);
    if(cameraNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag camera in the file");
        return(false);
    }
    if(cameraNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one camera node");
        return(false);
    }
    QDomNode cameraNode=cameraNodes.at(0);
    QDomElement cameraElement=cameraNode.toElement();

    QDomNodeList calibrationsNodes=cameraElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
    QDomElement calibrationsElement;
    if(calibrationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one calibrations nodes in camera node");
        return(false);
    }
    else if(calibrationsNodes.size()==1)
    {
        calibrationsElement=calibrationsNodes.at(0).toElement();
        cameraElement.removeChild(calibrationsElement);
    }
    else if(calibrationsNodes.size()==0)
    {
        calibrationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATIONS);
    }
    QDomNodeList calibrationNodes=calibrationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
    QDomElement calibrationElement;
    QDomElement calibrationElementToReplace;
    int posEqualCalibration=-1;
    if(calibrationNodes.size()==0)
    {
        calibrationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
    }
    else
    {
        for(int nC=0;nC<calibrationNodes.size();nC++)
        {
            QDomElement auxCalibrationElement=calibrationNodes.at(nC).toElement();
            QString strId=auxCalibrationElement.attribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID).trimmed();
            if(strId.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nCalibration node number %1, not found id attribute").arg(QString::number(nC+1));
                return(false);
            }
            if(strId.compare(calibrationId)==0)
            {
                calibrationElementToReplace=auxCalibrationElement;
                posEqualCalibration=nC;
                break;
            }
        }
        calibrationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_CALIBRATION);
    }
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ID,calibrationId);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_ENGINE,calibrationEngine);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_MODEL,calibrationModel);
    calibrationElement.setAttribute(ORTOSKYXMLMATCHESFILE_CALIBRATION_ATTRIBUTE_APERO_FILENAME,mCalibrationFileName);
    calibrationElement.appendChild(cameraModelXmlElement);
    if(posEqualCalibration>-1)
    {
        calibrationsElement.replaceChild(calibrationElement,calibrationElementToReplace);
    }
    else
        calibrationsElement.appendChild(calibrationElement);
    cameraElement.appendChild(calibrationsElement);

    QDomNodeList projectNodes=mDoc.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PROJECT);
    if(projectNodes.size()==0)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nNo tag project in the file");
        return(false);
    }
    if(projectNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one project node");
        return(false);
    }
    QDomElement projectElement=projectNodes.at(0).toElement();
    QDomNodeList orientationsNodes=projectElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
    QDomElement orientationsElement;
    if(orientationsNodes.size()>1)
    {
        strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
        strError+=QObject::tr("\nThere are more than one orientations nodes in camera node");
        return(false);
    }
    else if(orientationsNodes.size()==1)
    {
        orientationsElement=orientationsNodes.at(0).toElement();
        projectElement.removeChild(orientationsElement);
    }
    else if(orientationsNodes.size()==0)
    {
        orientationsElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATIONS);
    }
    orientationsElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATIONS_ATTRIBUTE_CURRENT,calibrationId);
    QDomNodeList orientationNodes=orientationsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATION);
    QDomElement orientationElement;
    QDomElement orientationElementToReplace;
    int posEqualOrientation=-1;
    if(orientationNodes.size()==0)
    {
        orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATION);
    }
    else
    {
        for(int nC=0;nC<orientationNodes.size();nC++)
        {
            QDomElement auxOrientationElement=orientationNodes.at(nC).toElement();
            QString strId=auxOrientationElement.attribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID).trimmed();
            if(strId.isEmpty())
            {
                strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile, error in file:\n%1").arg(mXmlFileName);
                strError+=QObject::tr("\nOrientation node number %1, not found id attribute").arg(QString::number(nC+1));
                return(false);
            }
            if(strId.compare(calibrationId)==0)
            {
                orientationElementToReplace=auxOrientationElement;
                posEqualOrientation=nC;
                break;
            }
        }
        orientationElement=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_ORIENTATION);
    }
    orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_ID,calibrationId);
    if(mOrientationIsFixed)
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_TYPE,
                                        ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_FIXED);
    else
        orientationElement.setAttribute(ORTOSKYXMLMATCHESFILE_ORIENTATION_ATTRIBUTE_TYPE,
                                        ORTOSKYXMLMATCHESFILE_ORIENTATION_TYPE_FREE);
    iter=mImagesFileNameByPos.begin();
    while(iter!=mImagesFileNameByPos.end())
    {
        int imagePos=iter.key();
        QString imageId=iter.value();
        QDomElement imgOrientation=mDoc.createElement(ORTOSKYXMLMATCHESFILE_TAG_IMAGE_ORIENTATION);
        imgOrientation.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_POSITION,
                                    QString::number(imagePos));
        imgOrientation.setAttribute(ORTOSKYXMLMATCHESFILE_IMAGE_ORIENTATION_ATTRIBUTE_ID,
                                    imageId);
        imgOrientation.appendChild(exteriorOrientationXmlElements[imageId]);
        orientationElement.appendChild(imgOrientation);
        iter++;
    }
    if(posEqualOrientation>-1)
    {
        orientationsElement.replaceChild(orientationElement,orientationElementToReplace);
    }
    else
        orientationsElement.appendChild(orientationElement);
    projectElement.appendChild(orientationsElement);

    // Actualización de las precisiones
    QDomNodeList correlatedInfoNodes=projectElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_CORRELATEDINFO);
    QDomElement correlatedInfoElement=correlatedInfoNodes.at(0).toElement();
    projectElement.removeChild(correlatedInfoElement);
    QDomNodeList pairsNodes=correlatedInfoElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIRS);
    QDomNode pairsNode=pairsNodes.at(0);
    QDomElement pairsElement=pairsNode.toElement();
    correlatedInfoElement.removeChild(pairsElement);
    QDomNodeList pairNodes=pairsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR);
    for(int nPairNode=0;nPairNode<pairNodes.size();nPairNode++)
    {
        QDomNode pairNode=pairNodes.at(nPairNode);
        QDomElement pairElement=pairNode.toElement();
        pairsElement.removeChild(pairElement);

        QDomNodeList photo1DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO1);
        QDomElement photo1Element=photo1DataNodes.at(0).toElement();
        QString strPhoto1=photo1Element.text();
        bool toInt=false;
        int photo1=strPhoto1.toInt(&toInt);

        QDomNodeList photo2DataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_PAIR_PHOTO2);
        QDomElement photo2Element=photo2DataNodes.at(0).toElement();
        QString strPhoto2=photo2Element.text();
        toInt=false;
        int photo2=strPhoto2.toInt(&toInt);

        QString image1FileName=mImagesFileNameByPos[photo1];
        QString image2FileName=mImagesFileNameByPos[photo2];

        QDomNodeList pointsDataNodes=pairElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINTS);
        if(pointsDataNodes.size()==0) // De esta forma no figuran pares sin puntos
            continue;

        QDomElement pointsElement=pointsDataNodes.at(0).toElement();
        pairElement.removeChild(pointsElement);
        QDomNodeList pntsDataNodes=pointsElement.elementsByTagName(ORTOSKYXMLMATCHESFILE_TAG_POINT);
        if(pntsDataNodes.size()<3)
        {
            continue;
//            strError=QObject::tr("ExternalInterfaceProcessMonitor::readOrtoSkyXmlProjectFile, error in file:\n%1").arg(fileName);
//            strError+=QObject::tr("\nIn pair node number %1, the number of matches is less than tree").arg(QString::number(nPairNode+1));
//            return(false);
        }

        QVector<float> accuracies;
        bool findAccuracies=false;
        if(mMatchesAccuracies.contains(image1FileName))
        {
            if(mMatchesAccuracies[image1FileName].contains(image2FileName))
            {
                findAccuracies=true;
                accuracies=mMatchesAccuracies[image1FileName][image2FileName];
            }
        }
//        if(!findAccuracies)
//        {
//            if(matchesAccuracies.contains(image2FileName))
//            {
//                if(matchesAccuracies[image2FileName].contains(image1FileName))
//                {
//                    findAccuracies=true;
//                    accuracies=matchesAccuracies[image2FileName][image1FileName];
//                }
//            }
//        }
        if(!findAccuracies)
        {
            strError=QObject::tr("OrientationProcessMonitor::writeSolutionToOrtoSkyXmlFile");
            strError+=QObject::tr("\nNot found matches accuracies for pair: %1 - %2").arg(image1FileName).arg(image2FileName);
            return(false);
        }
        for(int nPnt=0;nPnt<pntsDataNodes.size();nPnt++)
        {
            QDomElement pntElement=pntsDataNodes.at(nPnt).toElement();
            pointsElement.removeChild(pntElement);
            pntElement.setAttribute(ORTOSKYXMLMATCHESFILE_ATTRIBUTE_ACCURACY,
                                    QString::number(accuracies[nPnt],'f',mImageCoordinatesPrecision));
            pointsElement.appendChild(pntElement);
        }
        pairElement.appendChild(pointsElement);
        pairsElement.appendChild(pairElement);
    }
    correlatedInfoElement.appendChild(pairsElement);
    projectElement.appendChild(correlatedInfoElement);

    const int IndentSize = 4;
    QFile file(mXmlFileName);
    if (!file.open(QFile::WriteOnly | QFile::Text))
    {
        strError=tr("Error opening xml file:\n%1").arg(mXmlFileName);
        return(false);
    }
    QTextStream out(&file);
    mDoc.save(out, IndentSize);
    return(true);
}
*/
